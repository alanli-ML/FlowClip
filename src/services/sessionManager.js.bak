const { EventEmitter } = require('events');
const AISessionSummarizer = require('./aiSessionSummarizer');
const { v4: uuidv4 } = require('uuid');

class SessionManager extends EventEmitter {
  constructor(database, aiService, externalApiService = null, workflowEngine = null) {
    super();
    this.database = database;
    this.aiService = aiService;
    this.externalApiService = externalApiService;
    this.workflowEngine = workflowEngine;
    this.aiSummarizer = new AISessionSummarizer(aiService);    this.activeSessions = new Map();
    this.sessionTimeout = 60 * 60 * 1000; // 1 hour in milliseconds (was 10 minutes)
    this.sessionCleanupInterval = null;
    this.isInitialized = false;
  }

  async init() {
    if (this.isInitialized) return;
    
    // Initialize database tables for session management
    await this.createSessionTables();
    
    // Start session cleanup interval
    this.sessionCleanupInterval = setInterval(() => {
      this.cleanupExpiredSessions();
    }, 60 * 1000); // Check every minute
    
    this.isInitialized = true;
    console.log('SessionManager initialized');
  }

  async createSessionTables() {
    // Session table
    this.database.db.exec(`
      CREATE TABLE IF NOT EXISTS clipboard_sessions (
        id TEXT PRIMARY KEY,
        session_type TEXT NOT NULL,
        session_label TEXT,
        start_time DATETIME NOT NULL,
        last_activity DATETIME NOT NULL,
        status TEXT DEFAULT 'active',
        context_summary TEXT,
        intent_analysis TEXT,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Session members table
    this.database.db.exec(`
      CREATE TABLE IF NOT EXISTS session_members (
        session_id TEXT NOT NULL,
        clipboard_item_id TEXT NOT NULL,
        sequence_order INTEGER,
        added_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (session_id) REFERENCES clipboard_sessions(id) ON DELETE CASCADE,
        FOREIGN KEY (clipboard_item_id) REFERENCES clipboard_items(id) ON DELETE CASCADE,
        PRIMARY KEY (session_id, clipboard_item_id)
      )
    `);

    // Create indexes
    this.database.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_sessions_status ON clipboard_sessions(status);
      CREATE INDEX IF NOT EXISTS idx_sessions_type ON clipboard_sessions(session_type);
      CREATE INDEX IF NOT EXISTS idx_sessions_activity ON clipboard_sessions(last_activity);
      CREATE INDEX IF NOT EXISTS idx_session_members_session ON session_members(session_id);
    `);
  }

  async processClipboardItem(clipboardItem) {
    console.log(`SessionManager: Processing clipboard item for session detection: "${clipboardItem.content.substring(0, 30)}..."`);
    console.log(`SessionManager: Source app: ${clipboardItem.source_app}, Window: ${clipboardItem.window_title}`);
    
    try {
      // Ensure clipboard item exists in database before session processing
      console.log(`SessionManager: Ensuring clipboard item ${clipboardItem.id} exists in database...`);
      await this.ensureClipboardItemInDatabase(clipboardItem);
      console.log(`SessionManager: Clipboard item saved to database successfully`);
      
      // Analyze potential session membership
      console.log(`SessionManager: Finding session candidates...`);
      const sessionCandidates = await this.findSessionCandidates(clipboardItem);
      console.log(`SessionManager: Found ${sessionCandidates.length} session candidates`);
      
      let targetSession = null;
      
      if (sessionCandidates.length > 0) {
        console.log(`SessionManager: Found ${sessionCandidates.length} candidates, evaluating membership...`);
        // Check if item belongs to existing session
        targetSession = await this.evaluateSessionMembership(clipboardItem, sessionCandidates);
        if (targetSession) {
          console.log(`SessionManager: Item belongs to existing session ${targetSession.id} (${targetSession.session_type})`);
      } else {
          console.log(`SessionManager: Item does not belong to any existing session`);
        }
      }
      
      if (!targetSession) {
        console.log(`SessionManager: No existing session found, checking if new session should be created...`);
        // NEW LOGIC: Only create session if two consecutive entries have the same intent
        targetSession = await this.evaluateConsecutiveIntentForNewSession(clipboardItem);
        if (targetSession) {
          console.log(`SessionManager: New session created based on consecutive intent match: ${targetSession.id}`);
      } else {
          console.log(`SessionManager: No consecutive intent match found, item will remain standalone`);
        }
      }
      
      if (targetSession) {
        console.log(`SessionManager: Adding item ${clipboardItem.id} to session ${targetSession.id}`);
        // Add item to session (this will also trigger automatic research)
        await this.addItemToSession(targetSession.id, clipboardItem);
        console.log(`SessionManager: Item added to session successfully`);
        
        // Emit session updated event
        this.emit('session-updated', {
          sessionId: targetSession.id,
          sessionType: targetSession.session_type,
          itemCount: await this.getSessionItemCount(targetSession.id),
          newItem: clipboardItem
        });
        console.log(`SessionManager: Session-updated event emitted`);
      } else {
        console.log(`SessionManager: No session created or found, item remains standalone`);
      }
      
    } catch (error) {
      console.error('SessionManager: Error processing clipboard item for session detection:', error);
    }
  }

  async ensureClipboardItemInDatabase(clipboardItem) {
    try {
      // Check if the clipboard item already exists
      const existingItem = await this.database.getClipboardItem(clipboardItem.id);
      
      if (!existingItem) {
        console.log(`SessionManager: Saving clipboard item ${clipboardItem.id} to database for session processing`);
        await this.database.saveClipboardItem(clipboardItem);
      } else {
        console.log(`SessionManager: Clipboard item ${clipboardItem.id} already exists in database`);
      }
    } catch (error) {
      console.error('SessionManager: Error ensuring clipboard item in database:', error);
      throw error;
    }
  }

  async findSessionCandidates(clipboardItem) {
    const currentTime = new Date();
    const timeWindow = new Date(currentTime.getTime() - this.sessionTimeout);
    
    console.log(`SessionManager: Looking for candidates - current time: ${currentTime.toISOString()}, window: ${timeWindow.toISOString()}`);
    
    // Get active sessions within time window using datetime() function for proper comparison
    const stmt = this.database.db.prepare(`
      SELECT * FROM clipboard_sessions 
      WHERE status = 'active' 
      AND datetime(last_activity) >= datetime(?)
      ORDER BY datetime(last_activity) DESC
    `);
    
    const candidates = stmt.all(timeWindow.toISOString());
    console.log(`SessionManager: Found ${candidates.length} session candidates within ${this.sessionTimeout / 1000}s`);
    
    candidates.forEach(session => {
      console.log(`  Candidate: ${session.session_label} (${session.session_type}) - last activity: ${session.last_activity}`);
    });
    
    return candidates;
  }

  async evaluateSessionMembership(clipboardItem, sessionCandidates) {
    console.log(`SessionManager: Evaluating membership for "${clipboardItem.content.substring(0, 30)}..." against ${sessionCandidates.length} session candidates`);
    
    // Try LangGraph analysis first for intelligent membership evaluation
      if (this.aiService && this.aiService.langGraphClient) {
      console.log('  Using LangGraph for intelligent session membership evaluation...');
          
      for (const session of sessionCandidates) {
        try {
          const sessionItems = await this.getSessionItems(session.id);
          console.log(`    Evaluating membership in session: ${session.session_label} (${session.session_type}) with ${sessionItems.length} items`);
          
          const membershipResult = await this.aiService.langGraphClient.executeWorkflow('session_management', {
            content: clipboardItem.content,
            context: {
              sourceApp: clipboardItem.source_app,
              windowTitle: clipboardItem.window_title,
              screenshotPath: clipboardItem.screenshot_path
            },
            existingSession: {
              type: session.session_type,
              label: session.session_label,
              items: sessionItems.map(item => ({
                content: item.content,
                sourceApp: item.source_app,
                windowTitle: item.window_title,
                timestamp: item.timestamp
              }))
            }
          });

          console.log(`    LangGraph membership result:`, membershipResult);
          console.log(`    Membership confidence: ${membershipResult?.membershipConfidence}, belongs: ${membershipResult?.belongsToSession}`);

          // Enhanced criteria: accept high confidence OR detect cross-session-type themes
          if (membershipResult?.belongsToSession) {
            if (membershipResult.membershipConfidence > 0.6) {
              console.log(`    ✅ High confidence membership (${membershipResult.membershipConfidence}) - joining session`);
              return session;
            } else if (membershipResult.membershipConfidence > 0.4 && this.detectCrossSessionTheme(clipboardItem, session, sessionItems)) {
              console.log(`    ✅ Cross-session theme detected with moderate confidence (${membershipResult.membershipConfidence}) - joining session`);
            return session;
          }
        }

          // Check for thematic compatibility even with different session types
          if (membershipResult.membershipConfidence > 0.3) {
            const themeCompatibility = await this.evaluateThematicCompatibility(clipboardItem, session, sessionItems);
            if (themeCompatibility.isCompatible) {
              console.log(`    ✅ Thematic compatibility detected: ${themeCompatibility.theme} - joining session across types`);
              // Update session type to be more general if joining across types
              if (session.session_type !== themeCompatibility.suggestedSessionType) {
                await this.updateSessionType(session.id, themeCompatibility.suggestedSessionType, themeCompatibility.theme);
      }
              return session;
            }
          }

    } catch (error) {
          console.log(`    Error in LangGraph membership evaluation for session ${session.id}:`, error.message);
    }
      }
    }

    console.log('  Falling back to enhanced pattern-based membership evaluation...');
    // Enhanced fallback with theme detection
    return this.evaluateSessionMembershipWithThemes(clipboardItem, sessionCandidates);
  }

  async evaluateThematicCompatibility(clipboardItem, session, sessionItems) {
    try {
      console.log(`    Evaluating thematic compatibility between new item and session ${session.session_label}`);
      
      if (this.aiService && this.aiService.langGraphClient) {
        const themeAnalysis = await this.aiService.langGraphClient.executeWorkflow('session_management', {
          content: `Theme Analysis: New item "${clipboardItem.content.substring(0, 100)}..." vs Session "${session.session_label}" with items: ${sessionItems.map(item => item.content.substring(0, 50)).join('; ')}`,
          context: {
            sourceApp: 'ThemeAnalyzer',
            windowTitle: 'Cross-Session Theme Detection',
            analysisType: 'thematic_compatibility'
          },
          existingSession: {
            type: session.session_type,
            label: session.session_label,
            items: sessionItems.map(item => ({
              content: item.content,
              sourceApp: item.source_app,
              windowTitle: item.window_title
            }))
          }
        });

        // Extract theme information from the analysis
        const sessionReasoning = themeAnalysis?.sessionReasoning || '';
        const intentAnalysis = themeAnalysis?.intentAnalysis || {};
        
        // Look for location-based themes
        const locationThemes = this.extractLocationThemes(clipboardItem, sessionItems);
        if (locationThemes.commonLocation) {
          return {
            isCompatible: true,
            theme: `${locationThemes.commonLocation} Planning`,
            suggestedSessionType: 'travel_planning',
            reasoning: `Both involve ${locationThemes.commonLocation} - combining travel planning activities`,
            confidence: 0.8
          };
        }

        // Look for event-based themes
        const eventThemes = this.extractEventThemes(clipboardItem, sessionItems);
        if (eventThemes.commonEvent) {
          return {
            isCompatible: true,
            theme: `${eventThemes.commonEvent} Planning`,
            suggestedSessionType: 'event_planning',
            reasoning: `Both related to ${eventThemes.commonEvent}`,
            confidence: 0.75
          };
        }

        // Look for temporal themes (same time period)
        const temporalThemes = this.extractTemporalThemes(clipboardItem, sessionItems);
        if (temporalThemes.commonTimeframe) {
          return {
            isCompatible: true,
            theme: `${temporalThemes.commonTimeframe} Planning`,
            suggestedSessionType: 'general_planning',
            reasoning: `Activities planned for ${temporalThemes.commonTimeframe}`,
            confidence: 0.65
          };
        }

        // Look for project/work themes
        const projectThemes = this.extractProjectThemes(clipboardItem, sessionItems);
        if (projectThemes.commonProject) {
          return {
            isCompatible: true,
            theme: `${projectThemes.commonProject}`,
            suggestedSessionType: 'project_research',
            reasoning: `Related to ${projectThemes.commonProject} project`,
            confidence: 0.7
          };
        }
      }

      return { isCompatible: false };
    } catch (error) {
      console.log('    Theme compatibility analysis failed:', error.message);
      return { isCompatible: false };
    }
  }

  // Location-based theme detection
  extractLocationThemes(clipboardItem, sessionItems) {
    const locations = ['Toronto', 'Montreal', 'Vancouver', 'New York', 'Los Angeles', 'Chicago', 'Boston', 'Austin', 'Miami', 'Seattle', 'Portland', 'Denver', 'Las Vegas', 'San Francisco', 'Washington', 'Philadelphia', 'Phoenix', 'Dallas', 'Houston', 'Atlanta'];
    
    const newItemContent = clipboardItem.content.toLowerCase();
    const sessionContent = sessionItems.map(item => item.content.toLowerCase()).join(' ');
    
    for (const location of locations) {
      const locationLower = location.toLowerCase();
      if (newItemContent.includes(locationLower) && sessionContent.includes(locationLower)) {
        console.log(`      Found common location theme: ${location}`);
        return { commonLocation: location };
      }
    }
    
    return {};
  }

  // Event-based theme detection
  extractEventThemes(clipboardItem, sessionItems) {
    const events = ['wedding', 'conference', 'meeting', 'vacation', 'trip', 'business trip', 'honeymoon', 'anniversary', 'birthday', 'graduation', 'interview', 'presentation'];
    
    const newItemContent = clipboardItem.content.toLowerCase();
    const sessionContent = sessionItems.map(item => item.content.toLowerCase()).join(' ');
    
    for (const event of events) {
      if (newItemContent.includes(event) && sessionContent.includes(event)) {
        console.log(`      Found common event theme: ${event}`);
        return { commonEvent: event };
      }
    }
    
    return {};
  }

  // Temporal theme detection
  extractTemporalThemes(clipboardItem, sessionItems) {
    const timeframes = ['next week', 'next month', 'this weekend', 'next weekend', 'december', 'january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', '2024', '2025'];
    
    const newItemContent = clipboardItem.content.toLowerCase();
    const sessionContent = sessionItems.map(item => item.content.toLowerCase()).join(' ');
    
    for (const timeframe of timeframes) {
      if (newItemContent.includes(timeframe) && sessionContent.includes(timeframe)) {
        console.log(`      Found common temporal theme: ${timeframe}`);
        return { commonTimeframe: timeframe };
      }
    }
    
    return {};
  }

  // Project theme detection
  extractProjectThemes(clipboardItem, sessionItems) {
    const projects = ['website', 'app', 'presentation', 'report', 'proposal', 'research', 'analysis', 'study', 'design', 'development'];
    
    const newItemContent = clipboardItem.content.toLowerCase();
    const sessionContent = sessionItems.map(item => item.content.toLowerCase()).join(' ');
    
    for (const project of projects) {
      if (newItemContent.includes(project) && sessionContent.includes(project)) {
        console.log(`      Found common project theme: ${project}`);
        return { commonProject: project };
      }
    }
    
    return {};
  }

  async updateSessionType(sessionId, newSessionType, newTheme) {
    try {
      console.log(`    Updating session ${sessionId} type from existing to ${newSessionType} with theme: ${newTheme}`);
      
      const updateStmt = this.database.db.prepare(`
        UPDATE clipboard_sessions 
        SET session_type = ?, session_label = ?, last_activity = CURRENT_TIMESTAMP
        WHERE id = ?
      `);
      
      updateStmt.run(newSessionType, newTheme, sessionId);
      
      console.log(`    ✅ Session type updated to ${newSessionType} with label: ${newTheme}`);
    } catch (error) {
      console.error('    Error updating session type:', error);
    }
  }

  detectCrossSessionTheme(clipboardItem, session, sessionItems) {
    console.log(`    Detecting cross-session themes between ${clipboardItem.content.substring(0, 30)}... and session ${session.session_label}`);
    
    // Quick pattern-based theme detection
    const newContent = clipboardItem.content.toLowerCase();
    const sessionContent = sessionItems.map(item => item.content.toLowerCase()).join(' ');
    
    // Location-based themes
    const locationMatch = this.extractLocationThemes(clipboardItem, sessionItems);
    if (locationMatch.commonLocation) {
      console.log(`      ✅ Location theme detected: ${locationMatch.commonLocation}`);
      return true;
    }
    
    // Event-based themes
    const eventMatch = this.extractEventThemes(clipboardItem, sessionItems);
    if (eventMatch.commonEvent) {
      console.log(`      ✅ Event theme detected: ${eventMatch.commonEvent}`);
      return true;
    }
    
    // Check for complementary session types (hotel + restaurant = travel planning)
    const complementaryTypes = {
      'hotel_research': ['restaurant_research', 'travel_research', 'general_research'],
      'restaurant_research': ['hotel_research', 'travel_research', 'general_research'],
      'travel_research': ['hotel_research', 'restaurant_research', 'general_research'],
      'product_research': ['general_research'],
      'academic_research': ['general_research']
    };
    
    const currentType = this.detectNewSessionTypeMinimal(clipboardItem);
    if (complementaryTypes[session.session_type]?.includes(currentType)) {
      console.log(`      ✅ Complementary session types detected: ${session.session_type} + ${currentType}`);
      return true;
    }
    
    return false;
  }

  async evaluateSessionMembershipWithThemes(clipboardItem, sessionCandidates) {
    console.log('  Enhanced pattern-based evaluation with theme detection...');
    
    for (const session of sessionCandidates) {
      console.log(`    Checking session: ${session.session_label} (${session.session_type})`);
      
      const sessionItems = await this.getSessionItems(session.id);
      const timeDiff = new Date() - new Date(session.last_activity);
      
      // First check exact session type membership (existing logic)
      const exactMatch = this.evaluateSessionMembershipMinimal(clipboardItem, [session]);
      if (exactMatch) {
        console.log(`      ✅ Exact session type match found`);
        return exactMatch;
      }
      
      // Then check thematic compatibility with extended time window
      if (timeDiff < 2 * 60 * 60 * 1000) { // 2 hours for theme-based matching
        const themeCompatibility = await this.evaluateThematicCompatibility(clipboardItem, session, sessionItems);
        if (themeCompatibility.isCompatible) {
          console.log(`      ✅ Thematic compatibility found: ${themeCompatibility.theme}`);
          
          // Update session to reflect the broader theme
          await this.updateSessionType(session.id, themeCompatibility.suggestedSessionType, themeCompatibility.theme);
          
          // Return the updated session info
          return {
            ...session,
            session_type: themeCompatibility.suggestedSessionType,
            session_label: themeCompatibility.theme
          };
      }
    }
    
      console.log(`      ❌ No membership found for session ${session.session_label}`);
    }
    
    return null;
  }

  isBrowserApp(appName) {
    const browserApps = ['Google Chrome', 'Safari', 'Firefox', 'Microsoft Edge', 'Arc'];
    return browserApps.includes(appName);
  }

  async detectNewSessionType(clipboardItem) {
    console.log(`SessionManager: Detecting session type for "${clipboardItem.content.substring(0, 30)}..."`);
    console.log(`SessionManager: Source app: ${clipboardItem.source_app}`);
    console.log(`SessionManager: Window title: ${clipboardItem.window_title}`);
    
    // Always try LangGraph first for intelligent session type detection
    try {
      if (this.aiService && this.aiService.langGraphClient) {
        console.log('  Using LangGraph for session type detection');
        console.log('  LangGraph client available:', !!this.aiService.langGraphClient);
        
        const sessionTypeResult = await this.aiService.langGraphClient.executeWorkflow('session_type_detection', {
          content: clipboardItem.content,
          context: {
            sourceApp: clipboardItem.source_app,
            windowTitle: clipboardItem.window_title,
            screenshotPath: clipboardItem.screenshot_path
          }
        });

        console.log(`  LangGraph session type result:`, sessionTypeResult);
        console.log(`  Session type: ${sessionTypeResult?.sessionType}, confidence: ${sessionTypeResult?.sessionConfidence}`);

        if (sessionTypeResult && sessionTypeResult.sessionType && sessionTypeResult.sessionConfidence > 0.6) {
          console.log(`  → Creating new session type via LangGraph: ${sessionTypeResult.sessionType}`);
          return sessionTypeResult.sessionType;
        } else {
          console.log(`  → LangGraph confidence too low (${sessionTypeResult?.sessionConfidence}) or no session type detected`);
        }
      } else {
        console.log('  LangGraph not available for session type detection');
        console.log('  AIService available:', !!this.aiService);
        console.log('  LangGraph client available:', !!this.aiService?.langGraphClient);
      }
    } catch (error) {
      console.error('SessionManager: Session type detection failed:', error);
      console.error('Error details:', error.message);
    }

    console.log('  Falling back to minimal session type detection...');
    // Minimal fallback - only create sessions for very obvious patterns
    const result = this.detectNewSessionTypeMinimal(clipboardItem);
    console.log(`  Minimal detection result: ${result}`);
    return result;
  }

  detectNewSessionTypeMinimal(clipboardItem) {
    // Improved fallback - detect obvious session types using keywords and patterns
    const content = clipboardItem.content.toLowerCase().trim();
    console.log(`  Minimal detection - Content length: ${content.length}`);
    console.log(`  Minimal detection - Source app: ${clipboardItem.source_app}`);
    console.log(`  Minimal detection - Is browser app: ${this.isBrowserApp(clipboardItem.source_app)}`);
    
    // Only create sessions for browser-based research
    if (this.isBrowserApp(clipboardItem.source_app)) {
      console.log(`  → Browser app detected, checking content patterns...`);
      
      // Hotel research patterns
      const hotelKeywords = ['hotel', 'resort', 'inn', 'suite', 'booking', 'marriott', 'hilton', 'hyatt', 'sheraton', 'ritz', 'four seasons', 'shangri'];
      const hasHotelKeyword = hotelKeywords.some(keyword => {
        const found = content.includes(keyword);
        if (found) console.log(`    Found hotel keyword: ${keyword}`);
        return found;
      });
      
      if (hasHotelKeyword) {
        console.log(`  → Creating hotel research session (keyword match)`);
        return 'hotel_research';
      }
      
      // Restaurant research patterns
      const restaurantKeywords = ['restaurant', 'menu', 'reservation', 'dining', 'cuisine', 'michelin', 'yelp'];
      const hasRestaurantKeyword = restaurantKeywords.some(keyword => {
        const found = content.includes(keyword);
        if (found) console.log(`    Found restaurant keyword: ${keyword}`);
        return found;
      });
      
      if (hasRestaurantKeyword) {
        console.log(`  → Creating restaurant research session (keyword match)`);
        return 'restaurant_research';
      }
      
      // Travel research patterns
      const travelKeywords = ['flight', 'airline', 'airport', 'vacation', 'trip', 'travel', 'destination'];
      const hasTravelKeyword = travelKeywords.some(keyword => {
        const found = content.includes(keyword);
        if (found) console.log(`    Found travel keyword: ${keyword}`);
        return found;
      });
      
      if (hasTravelKeyword) {
        console.log(`  → Creating travel research session (keyword match)`);
        return 'travel_research';
      }
      
      // Generic research for other browser content that looks like research
      const hasUppercase = /[A-Z]/.test(content);
      const notUrl = !content.startsWith('http');
      const goodLength = content.length > 5 && content.length < 500;
      
      console.log(`    Generic research check - Length OK: ${goodLength}, Has uppercase: ${hasUppercase}, Not URL: ${notUrl}`);
      
      if (goodLength && hasUppercase && notUrl) {
        console.log(`  → Creating general research session (fallback pattern)`);
        return 'general_research';
      }
    } else {
      console.log(`  → Not a browser app, skipping session creation`);
    }
    
    console.log(`  → No session type detected (minimal fallback)`);
    return null;
  }

  async createNewSession(sessionType, clipboardItem) {
    const sessionId = uuidv4();
    const now = new Date().toISOString();
    
    // Generate session label
    const sessionLabel = await this.generateSessionLabel(sessionType, clipboardItem);
    
    const stmt = this.database.db.prepare(`
      INSERT INTO clipboard_sessions (
        id, session_type, session_label, start_time, last_activity, status
      ) VALUES (?, ?, ?, ?, ?, 'active')
    `);
    
    stmt.run(sessionId, sessionType, sessionLabel, now, now);
    
    const session = {
      id: sessionId,
      session_type: sessionType,
      session_label: sessionLabel,
      start_time: now,
      last_activity: now,
      status: 'active'
    };
    
    this.activeSessions.set(sessionId, session);
    
    console.log(`SessionManager: Created new ${sessionType} session: ${sessionLabel}`);
    
    this.emit('session-created', { session, clipboardItem });
    
    return session;
  }

  async generateSessionLabel(sessionType, clipboardItem) {
    const labelTemplates = {
      hotel_research: 'Hotel Research',
      restaurant_research: 'Restaurant Research', 
      product_research: 'Product Research',
      academic_research: 'Academic Research',
      general_research: 'Research Session',
      travel_research: 'Travel Research'
    };
    
    let baseLabel = labelTemplates[sessionType] || 'Research Session';
    const content = clipboardItem.content;
    
    // For hotel research, prioritize location over specific hotel brand to encourage combination
    if (sessionType === 'hotel_research') {
      // Try to extract city names first (encourages combining all Toronto hotels)
      const cityMatch = content.match(/\b(Toronto|Montreal|Vancouver|New York|Los Angeles|Chicago|Boston|Austin|Miami|Seattle|Portland|Denver|Las Vegas)\b/i);
      if (cityMatch) {
        baseLabel += ` - ${cityMatch[1]}`;
        return baseLabel;
      }
      
      // Only use hotel brand if no city found
      const hotelBrands = ['Hilton', 'Marriott', 'Hyatt', 'Sheraton', 'Ritz', 'Four Seasons', 'Shangri', 'Thompson', 'W Hotel', 'Westin', 'Renaissance'];
      for (const brand of hotelBrands) {
        if (content.includes(brand)) {
          baseLabel += ` - ${brand}`;
          return baseLabel;
        }
      }
    }
    
    // For other research types, extract relevant context
    if (sessionType === 'restaurant_research') {
      // Look for city first, then cuisine types
      const cityMatch = content.match(/\b(Toronto|Montreal|Vancouver|New York|Los Angeles|Chicago|Boston|Austin|Miami|Seattle|Portland|Denver|Las Vegas)\b/i);
      if (cityMatch) {
        baseLabel += ` - ${cityMatch[1]}`;
        return baseLabel;
      }
      
      const cuisineMatch = content.match(/\b(Italian|French|Japanese|Chinese|Mexican|Thai|Indian|Mediterranean|Steakhouse)\b/i);
      if (cuisineMatch) {
        baseLabel += ` - ${cuisineMatch[1]}`;
        return baseLabel;
      }
    }
    
    // General location/proper noun extraction as fallback
    const properNounMatch = content.match(/\b([A-Z][a-z]{3,15})\b/);
    if (properNounMatch) {
      const properNoun = properNounMatch[1];
      // Filter out common words that aren't meaningful identifiers
      const commonWords = ['Hotel', 'Resort', 'Restaurant', 'The', 'And', 'For', 'With', 'About', 'This', 'That', 'From', 'Your', 'Our'];
      if (!commonWords.includes(properNoun) && properNoun.length < 20) {
        baseLabel += ` - ${properNoun}`;
      }
    }
    
    return baseLabel;
  }

  async addItemToSession(sessionId, clipboardItem) {
    const sequenceOrder = await this.getNextSequenceOrder(sessionId);
    
    const stmt = this.database.db.prepare(`
      INSERT OR REPLACE INTO session_members (
        session_id, clipboard_item_id, sequence_order
      ) VALUES (?, ?, ?)
    `);
    
    stmt.run(sessionId, clipboardItem.id, sequenceOrder);
    
    // Update session last activity
    const updateStmt = this.database.db.prepare(`
      UPDATE clipboard_sessions 
      SET last_activity = CURRENT_TIMESTAMP 
      WHERE id = ?
    `);
    
    updateStmt.run(sessionId);
    
    console.log(`SessionManager: Added item ${clipboardItem.id} to session ${sessionId}`);
    
    // Always update session metadata for the new item (regardless of research capability)
    await this.updateSessionMetadataForNewItem(sessionId, clipboardItem);
    
    // Check session size to determine if comprehensive research should run
    const sessionItemCount = await this.getSessionItemCount(sessionId);
    console.log(`SessionManager: Session now has ${sessionItemCount} items`);
    
    // Automatically trigger research for the new item (non-blocking, optional)
    this.performAutomaticResearch(sessionId, clipboardItem).catch(error => {
      console.error('SessionManager: Background automatic research failed:', error);
    });
    
    // Trigger comprehensive session research if session has 2+ items
    if (sessionItemCount >= 2) {
      console.log(`SessionManager: Session has ${sessionItemCount} items - triggering comprehensive session research`);
      
      // Run comprehensive session research (non-blocking)
      this.performSessionResearch(sessionId).catch(error => {
        console.error('SessionManager: Background comprehensive session research failed:', error);
      });
    } else {
      console.log(`SessionManager: Session only has ${sessionItemCount} item - skipping comprehensive research`);
    }
  }

  async updateSessionMetadataForNewItem(sessionId, clipboardItem) {
    try {
      console.log(`SessionManager: Updating session metadata for item ${clipboardItem.id} (regardless of research)`);
      
      // Get current session data
      const session = await this.getSession(sessionId);
      const sessionItems = await this.getSessionItems(sessionId);
      
      // Parse existing context summary
      let contextSummary = {};
      if (session.context_summary) {
        try {
          contextSummary = JSON.parse(session.context_summary);
        } catch (parseError) {
          console.log('SessionManager: Failed to parse existing context summary, starting fresh');
          contextSummary = {};
        }
      }

      // Parse existing intent analysis
      let intentAnalysis = {};
      if (session.intent_analysis) {
        try {
          intentAnalysis = JSON.parse(session.intent_analysis);
        } catch (parseError) {
          console.log('SessionManager: Failed to parse existing intent analysis, starting fresh');
          intentAnalysis = {};
        }
      }

      // Update basic session statistics (always, regardless of research)
      if (!contextSummary.sessionProgress) {
        contextSummary.sessionProgress = {
          totalItems: sessionItems.length,
          researchedItems: 0,
          nonResearchItems: 0,
          lastUpdated: new Date().toISOString()
        };
      } else {
        contextSummary.sessionProgress.totalItems = sessionItems.length;
        contextSummary.sessionProgress.lastUpdated = new Date().toISOString();
      }

      // Track all items, not just researched ones
      if (!contextSummary.allItems) {
        contextSummary.allItems = [];
      }
      
      // Add current item to the items list
      contextSummary.allItems.push({
        clipboardItemId: clipboardItem.id,
        sourceApp: clipboardItem.source_app,
        windowTitle: clipboardItem.window_title,
        timestamp: new Date().toISOString(),
        hasResearch: false // Will be updated later if research completes
      });

      // Keep only the 10 most recent items
      contextSummary.allItems = contextSummary.allItems.slice(-10);

      // Generate basic session summary that includes all items
      const sessionType = session.session_type.replace('_', ' ');
      const itemTypes = this.analyzeItemTypes(sessionItems);
      const sourceApps = [...new Set(sessionItems.map(item => item.source_app))];
      
      // Create inclusive session summary
      let basicSummary = `${sessionType} session with ${sessionItems.length} item${sessionItems.length > 1 ? 's' : ''}`;
      
      if (itemTypes.length > 0) {
        basicSummary += ` (${itemTypes.join(', ')})`;
      }
      
      if (sourceApps.length > 0) {
        basicSummary += ` from ${sourceApps.join(', ')}`;
      }

      // Only override session summary if we don't have a research-enhanced one
      if (!contextSummary.sessionSummary || !contextSummary.researchFindings) {
        contextSummary.sessionSummary = basicSummary;
      }

      // Update intent analysis with basic item analysis
      if (!intentAnalysis.basicAnalysis) {
        intentAnalysis.basicAnalysis = {};
      }
      
      intentAnalysis.basicAnalysis = {
        totalItems: sessionItems.length,
        contentTypes: itemTypes,
        sourceApplications: sourceApps,
        timespan: this.calculateSessionTimespan(sessionItems),
        lastUpdated: new Date().toISOString()
      };

      // Extract keywords from all content (not just research results)
      const allMetadata = sessionItems.map(item => `${item.source_app} ${item.window_title}`).join(' ');
      const basicKeywords = this.extractBasicKeywords(allMetadata);
      
      if (!intentAnalysis.contentKeywords) {
        intentAnalysis.contentKeywords = [];
      }
      
      // Merge new keywords with existing ones
      intentAnalysis.contentKeywords = [...new Set([...intentAnalysis.contentKeywords, ...basicKeywords])].slice(0, 15);

      // Save updated session data
      const updateStmt = this.database.db.prepare(`
        UPDATE clipboard_sessions 
        SET context_summary = ?, intent_analysis = ?, last_activity = CURRENT_TIMESTAMP
        WHERE id = ?
      `);
      
      updateStmt.run(
        JSON.stringify(contextSummary),
        JSON.stringify(intentAnalysis),
        sessionId
      );

      console.log('SessionManager: Successfully updated session metadata for new item');
      console.log(`SessionManager: Session now has ${sessionItems.length} total items with comprehensive tracking`);

    } catch (error) {
      console.error('SessionManager: Error updating session metadata for new item:', error);
    }
  }

  // Helper method to analyze content types of items
  analyzeItemTypes(sessionItems) {
    const types = new Set();
    
    sessionItems.forEach(item => {
      const content = item.content.toLowerCase();
      
      // Basic content type detection
      if (content.startsWith('http')) {
        types.add('URLs');
      } else if (content.includes('@') && content.includes('.')) {
        types.add('emails');
      } else if (/\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/.test(content)) {
        types.add('phone numbers');
      } else if (content.length > 200) {
        types.add('documents');
      } else if (content.length < 20) {
        types.add('short clips');
      } else {
        types.add('text content');
      }
    });
    
    return Array.from(types);
  }

  // Helper method to calculate session timespan
  calculateSessionTimespan(sessionItems) {
    if (sessionItems.length === 0) return 'unknown';
    
    const timestamps = sessionItems.map(item => new Date(item.timestamp)).sort();
    const earliest = timestamps[0];
    const latest = timestamps[timestamps.length - 1];
    
    const diffMs = latest - earliest;
    const diffMinutes = Math.floor(diffMs / (1000 * 60));
    const diffHours = Math.floor(diffMinutes / 60);
    
    if (diffHours > 24) {
      const diffDays = Math.floor(diffHours / 24);
      return `${diffDays} day${diffDays > 1 ? 's' : ''}`;
    } else if (diffHours > 0) {
      return `${diffHours} hour${diffHours > 1 ? 's' : ''}`;
    } else if (diffMinutes > 0) {
      return `${diffMinutes} minute${diffMinutes > 1 ? 's' : ''}`;
    } else {
      return 'less than a minute';
    }
  }

  // Helper method to extract basic keywords from content
  extractBasicKeywords(content) {
    // Simple keyword extraction from content
    const words = content.toLowerCase()
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 3)
      .filter(word => !['this', 'that', 'with', 'from', 'they', 'have', 'will', 'been', 'were', 'said', 'each', 'which', 'their', 'what', 'about', 'would', 'there', 'could', 'other', 'more'].includes(word));
    
    // Count word frequency
    const wordCounts = {};
    words.forEach(word => {
      wordCounts[word] = (wordCounts[word] || 0) + 1;
    });
    
    // Return top keywords
    return Object.entries(wordCounts)
      .filter(([word, count]) => count > 1)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 8)
      .map(([word]) => word);
  }

  async performAutomaticResearch(sessionId, clipboardItem) {
    try {
      console.log(`SessionManager: Performing automatic research for item ${clipboardItem.id} in session ${sessionId}`);
      
      // Get the session to understand its context
      const session = await this.getSession(sessionId);
      if (!session) {
        console.log('SessionManager: Session not found, skipping research');
        return;
      }

      // Check if WorkflowEngine is available
      if (!this.workflowEngine) {
        console.log('SessionManager: WorkflowEngine not available, skipping research');
        return;
      }

      // Execute research workflow on the clipboard item
      console.log('SessionManager: Executing research workflow...');
      const researchResult = await this.workflowEngine.executeWorkflow('research', {
        clipboardItem: clipboardItem,
        sessionContext: {
          sessionId: sessionId,
          sessionType: session.session_type,
          sessionLabel: session.session_label
        }
      });

      if (researchResult) {
        console.log('SessionManager: Research completed successfully');
        console.log('SessionManager: Research result keys:', Object.keys(researchResult));
        
        // Update session analysis with research results
        await this.updateSessionWithResearchResults(sessionId, clipboardItem, researchResult);
        
        // Trigger comprehensive session analysis update
        await this.updateComprehensiveSessionAnalysis(sessionId);
        
        // Emit research completed event
        this.emit('session-research-completed', {
          sessionId: sessionId,
          clipboardItemId: clipboardItem.id,
          researchResult: researchResult
        });
      } else {
        console.log('SessionManager: Research returned no results');
      }

    } catch (error) {
      console.error('SessionManager: Automatic research failed:', error);
      
      // Emit research failed event
      this.emit('session-research-failed', {
        sessionId: sessionId,
        clipboardItemId: clipboardItem.id,
        error: error.message
      });
      
      // Don't rethrow the error to prevent it from affecting session creation
    }
  }

  async updateSessionWithResearchResults(sessionId, clipboardItem, researchResult) {
    try {
      console.log(`SessionManager: Updating session ${sessionId} with research results`);
      
      // Get current session data
      const session = await this.getSession(sessionId);
      const sessionItems = await this.getSessionItems(sessionId);
      
      // Parse existing context summary
      let contextSummary = {};
      if (session.context_summary) {
        try {
          contextSummary = JSON.parse(session.context_summary);
        } catch (parseError) {
          console.log('SessionManager: Failed to parse existing context summary, starting fresh');
          contextSummary = {};
        }
      }

      // Parse existing intent analysis
      let intentAnalysis = {};
      if (session.intent_analysis) {
        try {
          intentAnalysis = JSON.parse(session.intent_analysis);
        } catch (parseError) {
          console.log('SessionManager: Failed to parse existing intent analysis, starting fresh');
          intentAnalysis = {};
        }
      }

      // Enhance context summary with research findings
      if (researchResult.research_summary || researchResult.researchSummary) {
        const researchSummary = researchResult.research_summary || researchResult.researchSummary;
        
        if (!contextSummary.researchFindings) {
          contextSummary.researchFindings = [];
        }
        
        // Add new research finding
        contextSummary.researchFindings.push({
          clipboardItemId: clipboardItem.id,
          researchSummary: researchSummary,
          keyFindings: researchResult.key_findings || researchResult.keyFindings || [],
          sources: researchResult.sources || [],
          timestamp: new Date().toISOString(),
          sourceApp: clipboardItem.source_app,
          contentType: 'research_result'
        });

        // Keep only the 5 most recent research findings
        contextSummary.researchFindings = contextSummary.researchFindings.slice(-5);

        // Update the corresponding item in allItems to mark it as researched
        if (contextSummary.allItems) {
          const itemIndex = contextSummary.allItems.findIndex(item => item.clipboardItemId === clipboardItem.id);
          if (itemIndex !== -1) {
            contextSummary.allItems[itemIndex].hasResearch = true;
            contextSummary.allItems[itemIndex].researchType = 'comprehensive';
          }
        }
      }

      // Update session progress and insights
      if (!contextSummary.sessionProgress) {
        contextSummary.sessionProgress = {
          totalItems: sessionItems.length,
          researchedItems: 1,
          nonResearchItems: sessionItems.length - 1,
          lastResearchedAt: new Date().toISOString()
        };
      } else {
        contextSummary.sessionProgress.totalItems = sessionItems.length;
        contextSummary.sessionProgress.researchedItems = (contextSummary.sessionProgress.researchedItems || 0) + 1;
        contextSummary.sessionProgress.nonResearchItems = sessionItems.length - contextSummary.sessionProgress.researchedItems;
        contextSummary.sessionProgress.lastResearchedAt = new Date().toISOString();
      }

      // Generate enhanced session summary that includes both researched and non-researched items
      if (contextSummary.researchFindings && contextSummary.researchFindings.length > 0) {
        const keyTopics = contextSummary.researchFindings
          .flatMap(finding => finding.keyFindings || [])
          .slice(0, 5);
        
        const totalSources = contextSummary.researchFindings
          .reduce((sum, finding) => sum + (finding.sources?.length || 0), 0);

        const researchCount = contextSummary.sessionProgress.researchedItems || 0;
        const nonResearchCount = contextSummary.sessionProgress.nonResearchItems || 0;

        let summaryParts = [`${session.session_type.replace('_', ' ')} session with ${sessionItems.length} items`];
        
        if (researchCount > 0) {
          summaryParts.push(`${researchCount} researched`);
        }
        
        if (nonResearchCount > 0) {
          summaryParts.push(`${nonResearchCount} reference items`);
        }
        
        if (keyTopics.length > 0) {
          summaryParts.push(`covering: ${keyTopics.join(', ')}`);
        }
        
        if (totalSources > 0) {
          summaryParts.push(`${totalSources} sources referenced`);
        }

        contextSummary.sessionSummary = summaryParts.join('. ') + '.';
      }

      // Update intent analysis with research insights
      if (researchResult.suggested_keywords || researchResult.researchQueries) {
        const keywords = researchResult.suggested_keywords || researchResult.researchQueries || [];
        
        if (!intentAnalysis.researchKeywords) {
          intentAnalysis.researchKeywords = [];
        }
        
        // Merge new keywords with existing ones
        intentAnalysis.researchKeywords = [...new Set([...intentAnalysis.researchKeywords, ...keywords])].slice(0, 10);
        
        // Update research progress
        intentAnalysis.researchProgress = {
          totalQueries: keywords.length,
          completedResearch: contextSummary.researchFindings?.length || 0,
          lastUpdated: new Date().toISOString()
        };
      }

      // Save updated session data
      const updateStmt = this.database.db.prepare(`
        UPDATE clipboard_sessions 
        SET context_summary = ?, intent_analysis = ?, last_activity = CURRENT_TIMESTAMP
        WHERE id = ?
      `);
      
      updateStmt.run(
        JSON.stringify(contextSummary),
        JSON.stringify(intentAnalysis),
        sessionId
      );

      console.log('SessionManager: Successfully updated session with research results');
      console.log(`SessionManager: Session now has ${contextSummary.researchFindings?.length || 0} research findings`);

    } catch (error) {
      console.error('SessionManager: Error updating session with research results:', error);
    }
  }

  async getNextSequenceOrder(sessionId) {
    const stmt = this.database.db.prepare(`
      SELECT COALESCE(MAX(sequence_order), 0) + 1 as next_order
      FROM session_members 
      WHERE session_id = ?
    `);
    
    const result = stmt.get(sessionId);
    return result.next_order;
  }

  async updateSessionAnalysis(sessionId) {
    try {
      const sessionItems = await this.getSessionItems(sessionId);
      const session = await this.getSession(sessionId);
      
      if (sessionItems.length < 2) return; // Need at least 2 items for analysis
      
      if (this.aiService && this.aiService.langGraphClient) {
        // Use LangGraph for session analysis
        const analysisResult = await this.aiService.langGraphClient.executeWorkflow('session_analysis', {
          sessionType: session.session_type,
          items: sessionItems.map(item => ({
            content: item.content,
            sourceApp: item.source_app,
            windowTitle: item.window_title,
            timestamp: item.timestamp
          }))
        });
        
        // Update session with analysis
        const updateStmt = this.database.db.prepare(`
          UPDATE clipboard_sessions 
          SET context_summary = ?, intent_analysis = ?
          WHERE id = ?
        `);
        
        updateStmt.run(
          JSON.stringify(analysisResult.contextSummary),
          JSON.stringify(analysisResult.intentAnalysis),
          sessionId
        );
      }
    } catch (error) {
      console.error('SessionManager: Session analysis failed:', error);
    }
  }

  async getSession(sessionId) {
    const stmt = this.database.db.prepare('SELECT * FROM clipboard_sessions WHERE id = ?');
    return stmt.get(sessionId);
  }

  async getSessionItems(sessionId) {
    const stmt = this.database.db.prepare(`
      SELECT c.* FROM clipboard_items c
      JOIN session_members sm ON c.id = sm.clipboard_item_id
      WHERE sm.session_id = ?
      ORDER BY sm.sequence_order ASC
    `);
    
    return stmt.all(sessionId).map(row => ({
      ...row,
      tags: JSON.parse(row.tags || '[]')
    }));
  }

  async getSessionItemCount(sessionId) {
    const stmt = this.database.db.prepare('SELECT COUNT(*) as count FROM session_members WHERE session_id = ?');
    const result = stmt.get(sessionId);
    return result.count;
  }

  async getActiveSessions() {
    // Return ALL sessions (active and expired) for persistent UI display
    const stmt = this.database.db.prepare(`
      SELECT s.*, COUNT(sm.clipboard_item_id) as item_count
      FROM clipboard_sessions s
      LEFT JOIN session_members sm ON s.id = sm.session_id
      GROUP BY s.id
      ORDER BY s.last_activity DESC
    `);
    
    return stmt.all();
  }

  async getSessionsByType(sessionType) {
    const stmt = this.database.db.prepare(`
      SELECT s.*, COUNT(sm.clipboard_item_id) as item_count
      FROM clipboard_sessions s
      LEFT JOIN session_members sm ON s.id = sm.session_id
      WHERE s.session_type = ?
      GROUP BY s.id
      ORDER BY s.last_activity DESC
    `);
    
    return stmt.all(sessionType);
  }

  cleanupExpiredSessions() {
    // Sessions never expire - they remain active indefinitely for persistent UI display
    // This ensures users always see their research sessions in the UI
    console.log('SessionManager: Session expiration disabled - all sessions remain active');
        return;
  }

  async triggerExternalAutomation(session, itemCount) {
    if (!this.externalApiService) {
      return; // External automation not configured
    }

    try {
      // Get session items for automation context
      const sessionItems = await this.getSessionItems(session.id);
      
      const sessionData = {
        sessionId: session.id,
        sessionType: session.session_type,
        sessionLabel: session.session_label,
        itemCount,
        items: sessionItems,
        lastActivity: session.last_activity,
        startTime: session.start_time
      };

      console.log(`SessionManager: Triggering external automation for session ${session.session_label} (${itemCount} items)`);
      
      const result = await this.externalApiService.processSessionUpdate(sessionData);
      
      if (result) {
        console.log(`SessionManager: External automation triggered successfully: ${result.workflowId}`);
        
        // Emit automation event
        this.emit('automation-triggered', {
          sessionId: session.id,
          sessionType: session.session_type,
          workflowId: result.workflowId,
          automationResult: result
        });
      }
      
    } catch (error) {
      console.error('SessionManager: External automation failed:', error);
      
      this.emit('automation-failed', {
        sessionId: session.id,
        sessionType: session.session_type,
        error: error.message
      });
    }
  }

  // External automation management
  enableExternalAutomation(externalApiService) {
    this.externalApiService = externalApiService;
    console.log('SessionManager: External automation enabled');
  }

  disableExternalAutomation() {
    this.externalApiService = null;
    console.log('SessionManager: External automation disabled');
  }

  isExternalAutomationEnabled() {
    return this.externalApiService !== null;
  }

  async clearAllSessions() {
    try {
      console.log('SessionManager: Clearing all sessions...');
      
      // Delete all session members first (due to foreign key constraints)
      const deleteSessionMembersStmt = this.database.db.prepare('DELETE FROM session_members');
      deleteSessionMembersStmt.run();
      
      // Delete all sessions
      const deleteSessionsStmt = this.database.db.prepare('DELETE FROM clipboard_sessions');
      const result = deleteSessionsStmt.run();
      
      // Clear in-memory sessions
      this.activeSessions.clear();
      
      console.log(`SessionManager: Cleared ${result.changes} sessions and all associated data`);
      
      // Emit event to notify UI
      this.emit('all-sessions-cleared');
      
      return { success: true, clearedSessions: result.changes };
    } catch (error) {
      console.error('SessionManager: Error clearing all sessions:', error);
      throw error;
    }
  }

  destroy() {
    if (this.sessionCleanupInterval) {
      clearInterval(this.sessionCleanupInterval);
    }
  }

  async updateComprehensiveSessionAnalysis(sessionId) {
    try {
      console.log(`SessionManager: Running comprehensive session analysis for session ${sessionId}`);
      
      // Get current session and all its items
      const session = await this.getSession(sessionId);
      const sessionItems = await this.getSessionItems(sessionId);
      
      if (sessionItems.length === 0) {
        console.log('SessionManager: No items in session, skipping comprehensive analysis');
        return;
      }

      console.log(`SessionManager: Analyzing ${sessionItems.length} items in session`);

      // Collect all research results from session items
      const sessionItemsWithResearch = [];
      const allResearchFindings = [];
      const allKeywords = [];
      const allSources = [];
      let researchedItemCount = 0;
      let nonResearchedItemCount = 0;
      
      for (const item of sessionItems) {
        let analysisData = null;
        let hasResearch = false;
        
        if (item.analysis_data) {
          try {
            analysisData = JSON.parse(item.analysis_data);
            
            // Extract research results from workflow results
            if (analysisData.workflowResults && analysisData.workflowResults.research) {
              const researchResults = analysisData.workflowResults.research;
              for (const research of researchResults) {
                if (research.researchSummary) {
                  hasResearch = true;
                  allResearchFindings.push({
                    itemId: item.id,
                    summary: research.researchSummary,
                    keyFindings: research.keyFindings || [],
                    sources: research.sources || [],
                    timestamp: research.timestamp,
                    sourceApp: item.source_app,
                    contentType: analysisData.contentType || 'unknown'
                  });
                  
                  // Collect keywords and sources
                  if (research.keyFindings) allKeywords.push(...research.keyFindings);
                  if (research.sources) allSources.push(...research.sources);
                }
              }
            }
          } catch (parseError) {
            console.log(`SessionManager: Error parsing analysis data for item ${item.id}:`, parseError.message);
          }
        }
        
        if (hasResearch) {
          researchedItemCount++;
        } else {
          nonResearchedItemCount++;
        }
        
        sessionItemsWithResearch.push({
          ...item,
          analysisData,
          hasResearch
        });
      }

      console.log(`SessionManager: Found ${allResearchFindings.length} research findings across ${sessionItems.length} items`);
      console.log(`SessionManager: ${researchedItemCount} items with research, ${nonResearchedItemCount} reference items`);

      // Generate comprehensive session analysis using LangGraph if available
      let comprehensiveAnalysis = null;
      if (this.aiService && this.aiService.langGraphClient) {
        console.log('SessionManager: Running comprehensive session workflow analysis...');
        
        try {
          // Include ALL items in the analysis, not just those with research
          const basicKeywords = this.extractBasicKeywords(sessionItems.map(item => `${item.source_app} ${item.window_title}`).join(' '));
          
          comprehensiveAnalysis = await this.aiService.langGraphClient.executeWorkflow('session_management', {
            content: `Comprehensive Session Analysis for ${session.session_type}: ${session.session_label}`,
            context: {
              sourceApp: 'SessionManager',
              windowTitle: `Session Analysis - ${session.session_label}`,
              sessionData: {
                sessionType: session.session_type,
                itemCount: sessionItems.length,
                researchedItems: researchedItemCount,
                nonResearchItems: nonResearchedItemCount,
                researchFindings: allResearchFindings,
                totalSources: allSources.length,
                keyTopics: [...new Set([...allKeywords, ...basicKeywords])].slice(0, 15),
                contentTypes: this.analyzeItemTypes(sessionItems),
                sourceApps: [...new Set(sessionItems.map(item => item.source_app))],
                timespan: this.calculateSessionTimespan(sessionItems)
              }
            },
            existingSession: {
              type: session.session_type,
              label: session.session_label,
              items: sessionItemsWithResearch.map(item => ({
                sourceApp: item.source_app,
                windowTitle: item.window_title,
                hasResearch: item.hasResearch,
                timestamp: item.timestamp,
                contentType: item.analysisData?.contentType || 'unknown'
              }))
            }
          });
          
          console.log('SessionManager: Comprehensive session analysis completed');
        } catch (error) {
          console.error('SessionManager: Comprehensive session analysis failed:', error);
        }
      }

      // Update session with comprehensive analysis
      let contextSummary = {};
      let intentAnalysis = {};
      
      // Parse existing session data
      if (session.context_summary) {
        try {
          contextSummary = JSON.parse(session.context_summary);
        } catch (parseError) {
          contextSummary = {};
        }
      }
      
      if (session.intent_analysis) {
        try {
          intentAnalysis = JSON.parse(session.intent_analysis);
        } catch (parseError) {
          intentAnalysis = {};
        }
      }

      // Update context summary with comprehensive findings (includes all items)
      contextSummary.comprehensiveAnalysis = {
        totalItems: sessionItems.length,
        researchedItems: researchedItemCount,
        nonResearchItems: nonResearchedItemCount,
        researchFindings: allResearchFindings.length,
        totalSources: allSources.length,
        keyTopics: [...new Set([...allKeywords, ...this.extractBasicKeywords(sessionItems.map(item => `${item.source_app} ${item.window_title}`).join(' '))])].slice(0, 15),
        contentTypes: this.analyzeItemTypes(sessionItems),
        sourceApplications: [...new Set(sessionItems.map(item => item.source_app))],
        timespan: this.calculateSessionTimespan(sessionItems),
        lastAnalyzed: new Date().toISOString(),
        sessionProgress: {
          researchCoverage: sessionItems.length > 0 ? Math.round((researchedItemCount / sessionItems.length) * 100) : 0,
          informationDensity: allSources.length > 10 ? 'high' : allSources.length > 5 ? 'medium' : 'low',
          analysisQuality: comprehensiveAnalysis ? 'ai-enhanced' : 'basic'
        }
      };

      // Create consolidated session summary that includes all items
      if (sessionItems.length > 0) {
        const sessionType = session.session_type.replace('_', ' ');
        const contentTypes = this.analyzeItemTypes(sessionItems);
        const sourceApps = [...new Set(sessionItems.map(item => item.source_app))];
        
        let summaryParts = [`${sessionType} session with ${sessionItems.length} items`];
        
        if (researchedItemCount > 0 && nonResearchedItemCount > 0) {
          summaryParts.push(`${researchedItemCount} researched, ${nonResearchedItemCount} reference items`);
        } else if (researchedItemCount > 0) {
          summaryParts.push(`${researchedItemCount} researched items`);
        } else {
          summaryParts.push(`${nonResearchedItemCount} reference items`);
        }
        
        if (contentTypes.length > 0) {
          summaryParts.push(`(${contentTypes.join(', ')})`);
        }
        
        if (allResearchFindings.length > 0) {
          const topKeywords = [...new Set(allKeywords)].slice(0, 5);
          if (topKeywords.length > 0) {
            summaryParts.push(`covering: ${topKeywords.join(', ')}`);
          }
          
          if (allSources.length > 0) {
            summaryParts.push(`${allSources.length} sources referenced`);
          }
        }
        
        contextSummary.sessionSummary = comprehensiveAnalysis?.sessionInsights || 
          summaryParts.join('. ') + '.';
        
        // Add timeline for all items (not just researched ones)
        contextSummary.itemTimeline = sessionItems
          .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
          .slice(0, 8)
          .map(item => ({
            timestamp: item.timestamp,
            sourceApp: item.source_app,
            windowTitle: item.window_title,
            hasResearch: sessionItemsWithResearch.find(sri => sri.id === item.id)?.hasResearch || false
          }));
      }

      // Update intent analysis with comprehensive insights
      if (comprehensiveAnalysis) {
        intentAnalysis.sessionIntent = {
          primaryGoal: comprehensiveAnalysis.intentAnalysis?.primaryIntent || 'research',
          progressStatus: comprehensiveAnalysis.intentAnalysis?.progressStatus || 'in_progress',
          nextActions: comprehensiveAnalysis.nextActions || [],
          confidenceLevel: comprehensiveAnalysis.sessionConfidence || 0.7,
          analysisReasoning: comprehensiveAnalysis.sessionReasoning || 'Comprehensive analysis of session items'
        };
      }

      // Consolidate research insights across all items
      if (allResearchFindings.length > 1) {
        intentAnalysis.crossItemInsights = {
          commonThemes: this.extractCommonThemes(allResearchFindings),
          knowledgeGaps: this.identifyKnowledgeGaps(allResearchFindings, session.session_type),
          recommendedNextSteps: this.generateNextSteps(allResearchFindings, session.session_type),
          researchCoherence: this.assessResearchCoherence(allResearchFindings)
        };
      }

      // Save updated session analysis
      const updateStmt = this.database.db.prepare(`
        UPDATE clipboard_sessions 
        SET context_summary = ?, intent_analysis = ?, last_activity = CURRENT_TIMESTAMP
        WHERE id = ?
      `);
      
      updateStmt.run(
        JSON.stringify(contextSummary),
        JSON.stringify(intentAnalysis),
        sessionId
      );

      console.log('SessionManager: Comprehensive session analysis updated successfully');
      console.log(`SessionManager: Session now has ${allResearchFindings.length} research findings integrated`);

      // Emit comprehensive analysis event
      this.emit('session-analysis-updated', {
        sessionId: sessionId,
        sessionType: session.session_type,
        analysisData: {
          totalResearchFindings: allResearchFindings.length,
          totalSources: allSources.length,
          keyTopics: [...new Set(allKeywords)].slice(0, 5),
          hasComprehensiveAnalysis: !!comprehensiveAnalysis
        }
      });

    } catch (error) {
      console.error('SessionManager: Error in comprehensive session analysis:', error);
    }
  }

  // Helper methods for comprehensive analysis
  extractCommonThemes(researchFindings) {
    const allFindings = researchFindings.flatMap(finding => finding.keyFindings || []);
    const wordCounts = {};
    
    allFindings.forEach(finding => {
      const words = finding.toLowerCase().split(/\s+/);
      words.forEach(word => {
        if (word.length > 3) {
          wordCounts[word] = (wordCounts[word] || 0) + 1;
        }
      });
    });
    
    return Object.entries(wordCounts)
      .filter(([word, count]) => count > 1)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([word]) => word);
  }

  identifyKnowledgeGaps(researchFindings, sessionType) {
    const gaps = [];
    
    // Session-type specific gap analysis
    if (sessionType === 'hotel_research') {
      const hasLocationInfo = researchFindings.some(f => 
        f.keyFindings.some(finding => finding.toLowerCase().includes('location') || finding.toLowerCase().includes('area'))
      );
      const hasPriceInfo = researchFindings.some(f => 
        f.keyFindings.some(finding => finding.toLowerCase().includes('price') || finding.toLowerCase().includes('cost'))
      );
      
      if (!hasLocationInfo) gaps.push('Location and neighborhood information');
      if (!hasPriceInfo) gaps.push('Pricing and value comparison');
    }
    
    return gaps.slice(0, 3);
  }

  generateNextSteps(researchFindings, sessionType) {
    const steps = [];
    
    if (sessionType === 'hotel_research') {
      steps.push('Compare pricing across identified options');
      steps.push('Review customer reviews and ratings');
      if (researchFindings.length > 2) {
        steps.push('Create comparison matrix of key features');
      }
    } else if (sessionType === 'restaurant_research') {
      steps.push('Check availability and make reservations');
      steps.push('Review menu options and dietary accommodations');
    } else {
      steps.push('Gather additional sources for verification');
      steps.push('Organize findings into actionable insights');
    }
    
    return steps.slice(0, 3);
  }

  assessResearchCoherence(researchFindings) {
    // Simple coherence assessment based on keyword overlap
    const allKeywords = researchFindings.flatMap(f => f.keyFindings || []);
    const uniqueKeywords = new Set(allKeywords.map(k => k.toLowerCase()));
    
    const coherenceRatio = uniqueKeywords.size / (allKeywords.length || 1);
    
    if (coherenceRatio > 0.7) return 'low'; // Too many unique keywords, low coherence
    if (coherenceRatio > 0.4) return 'medium';
    return 'high'; // Good keyword overlap, high coherence
  }

  async performSessionResearch(sessionId) {
    try {
      console.log(`SessionManager: Performing comprehensive session research for session ${sessionId}`);
      
      // Get session and all its items
      const session = await this.getSession(sessionId);
      const sessionItems = await this.getSessionItems(sessionId);
      
      if (!session) {
        throw new Error('Session not found');
      }
      
      if (sessionItems.length === 0) {
        throw new Error('Session has no items to research');
      }

      console.log(`SessionManager: Researching session "${session.session_label}" with ${sessionItems.length} items`);

      // Analyze each entry's comprehensive analysis to generate specific research queries
      const entrySpecificResearch = await this.generateEntrySpecificResearchQueries(sessionItems, session.session_type);
      
      console.log(`SessionManager: Generated ${entrySpecificResearch.totalQueries} specific research queries from ${entrySpecificResearch.entries.length} entries`);

      // Check if WorkflowEngine and LangGraph are available
      if (!this.workflowEngine || !this.aiService?.langGraphClient) {
        throw new Error('Research capabilities not available');
      }

      // Execute targeted research for each specific query
      const researchResults = [];
      for (const entry of entrySpecificResearch.entries) {
        if (entry.researchQueries.length > 0) {
          console.log(`SessionManager: Researching entry ${entry.itemId} with ${entry.researchQueries.length} specific queries`);
          
          for (const query of entry.researchQueries) {
            try {
              const researchResult = await this.aiService.langGraphClient.executeWorkflow('research', {
                content: query.searchQuery,
                context: {
                  sourceApp: 'SessionResearcher',
                  windowTitle: `Specific Research: ${query.aspect}`,
                  sessionContext: {
                    sessionId: sessionId,
                    sessionType: session.session_type,
                    entryId: entry.itemId,
                    researchAspect: query.aspect,
                    researchType: 'entry_specific_research'
                  }
                },
                existingAnalysis: {
                  contentType: entry.contentType,
                  tags: entry.tags,
                  contextInsights: entry.contextInsights,
                  knownInformation: query.knownInfo,
                  researchGap: query.researchGap
                }
              });

              if (researchResult) {
                researchResults.push({
                  entryId: entry.itemId,
                  aspect: query.aspect,
                  query: query.searchQuery,
                  result: researchResult,
                  timestamp: new Date().toISOString()
                });
              }
            } catch (error) {
              console.error(`SessionManager: Error researching query "${query.searchQuery}":`, error.message);
            }
          }
        }
      }

      console.log(`SessionManager: Completed ${researchResults.length} specific research queries`);

      // Consolidate and structure all research results
      const consolidatedResults = await this.consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch);

      // Update session with comprehensive research results
      await this.updateSessionWithResearchResults(sessionId, consolidatedResults);

      // Emit session research completed event
      this.emit('session-research-completed', {
        sessionId: sessionId,
        sessionType: session.session_type,
        researchResults: consolidatedResults,
        itemCount: sessionItems.length,
        specificQueries: entrySpecificResearch.totalQueries,
        researchedEntries: entrySpecificResearch.entries.length
      });

      return consolidatedResults;

    } catch (error) {
      console.error('SessionManager: Error performing session research:', error);
      this.emit('session-research-failed', {
        sessionId: sessionId,
        error: error.message
      });
      throw error;
    }
  }

  async generateEntrySpecificResearchQueries(sessionItems, sessionType) {
    const entries = [];
    let totalQueries = 0;

    for (const item of sessionItems) {
      if (!item.analysis_data) {
        console.log(`SessionManager: Skipping item ${item.id} - no comprehensive analysis available`);
        continue;
      }

      try {
        const analysisData = JSON.parse(item.analysis_data);
        const entryAnalysis = {
          itemId: item.id,
          content: item.content,
          contentType: analysisData.contentType || 'unknown',
          tags: analysisData.tags || [],
          contextInsights: analysisData.contextInsights || '',
          visualContext: analysisData.visualContext || null,
          sourceApp: item.source_app,
          windowTitle: item.window_title
        };

        // Generate specific research queries based on content type and context
        const researchQueries = this.generateSpecificResearchQueries(entryAnalysis, sessionType);
        
        if (researchQueries.length > 0) {
          entries.push({
            ...entryAnalysis,
            researchQueries: researchQueries
          });
          totalQueries += researchQueries.length;
          console.log(`SessionManager: Generated ${researchQueries.length} queries for ${entryAnalysis.contentType} entry`);
        }

      } catch (parseError) {
        console.log(`SessionManager: Error parsing analysis data for item ${item.id}:`, parseError.message);
      }
    }

    return {
      entries: entries,
      totalQueries: totalQueries,
      sessionType: sessionType
    };
  }

  generateSpecificResearchQueries(entryAnalysis, sessionType) {
    const queries = [];
    const content = entryAnalysis.content.toLowerCase();
    const tags = entryAnalysis.tags;
    const contextInsights = entryAnalysis.contextInsights || '';
    
    // Extract specific entities from the content
    const entities = this.extractSpecificEntities(entryAnalysis);
    
    switch (entryAnalysis.contentType) {
      case 'url':
        queries.push(...this.generateURLSpecificQueries(entryAnalysis, entities, sessionType));
        break;
        
      case 'location':
      case 'address':
        queries.push(...this.generateLocationSpecificQueries(entryAnalysis, entities, sessionType));
        break;
        
      case 'person':
      case 'organization':
        queries.push(...this.generateEntitySpecificQueries(entryAnalysis, entities, sessionType));
        break;
        
      case 'product':
        queries.push(...this.generateProductSpecificQueries(entryAnalysis, entities, sessionType));
        break;
        
      case 'document':
      case 'data':
        queries.push(...this.generateDocumentSpecificQueries(entryAnalysis, entities, sessionType));
        break;
        
      default:
        queries.push(...this.generateGeneralSpecificQueries(entryAnalysis, entities, sessionType));
    }

    return queries.slice(0, 3); // Limit to 3 most important queries per entry
  }

  generateURLSpecificQueries(entryAnalysis, entities, sessionType) {
    const queries = [];
    const url = entryAnalysis.content;
    
    // Extract domain and infer content type
    const domain = url.match(/https?:\/\/(?:www\.)?([^\/]+)/)?.[1] || '';
    
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand) {
        queries.push({
          aspect: 'pricing_comparison',
          searchQuery: `${entities.hotelBrand} hotel ${entities.location || ''} pricing rates booking deals current offers`,
          knownInfo: `Hotel brand: ${entities.hotelBrand}`,
          researchGap: 'Current pricing, availability, special offers, booking comparison'
        });
        
        queries.push({
          aspect: 'amenities_details',
          searchQuery: `${entities.hotelBrand} ${entities.location || ''} amenities facilities services features guest reviews`,
          knownInfo: `Hotel: ${entities.hotelBrand}`,
          researchGap: 'Detailed amenities, guest experiences, facility quality'
        });
        
        if (entities.location) {
          queries.push({
            aspect: 'location_benefits',
            searchQuery: `${entities.hotelBrand} ${entities.location} location advantages nearby attractions transportation access`,
            knownInfo: `Hotel ${entities.hotelBrand} in ${entities.location}`,
            researchGap: 'Location advantages, nearby attractions, transportation options'
          });
        }
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName) {
        queries.push({
          aspect: 'menu_pricing',
          searchQuery: `${entities.restaurantName} ${entities.location || ''} menu prices current offerings specialties`,
          knownInfo: `Restaurant: ${entities.restaurantName}`,
          researchGap: 'Current menu, pricing, signature dishes, seasonal offerings'
        });
        
        queries.push({
          aspect: 'dining_experience',
          searchQuery: `${entities.restaurantName} ${entities.location || ''} reviews dining experience service quality atmosphere`,
          knownInfo: `Restaurant: ${entities.restaurantName}`,
          researchGap: 'Dining experience, service quality, atmosphere, customer reviews'
        });
      }
    } else if (sessionType === 'product_research') {
      if (entities.productName || entities.brand) {
        const product = entities.productName || entities.brand;
        queries.push({
          aspect: 'specifications_comparison',
          searchQuery: `${product} specifications features comparison alternatives competitors 2024`,
          knownInfo: `Product: ${product}`,
          researchGap: 'Detailed specifications, feature comparison, competitive analysis'
        });
        
        queries.push({
          aspect: 'pricing_availability',
          searchQuery: `${product} current price best deals where to buy availability stock`,
          knownInfo: `Product: ${product}`,
          researchGap: 'Current pricing, best deals, purchasing options, availability'
        });
      }
    }
    
    return queries;
  }

  generateLocationSpecificQueries(entryAnalysis, entities, sessionType) {
    const queries = [];
    const location = entities.location || entryAnalysis.content;
    
    if (sessionType === 'hotel_research') {
      queries.push({
        aspect: 'area_hotels',
        searchQuery: `best hotels ${location} luxury boutique budget options 2024 recommendations`,
        knownInfo: `Location: ${location}`,
        researchGap: 'Hotel options in the area, categories, recommendations'
      });
      
      queries.push({
        aspect: 'location_advantages',
        searchQuery: `${location} attractions nearby amenities transportation shopping dining convenience`,
        knownInfo: `Area: ${location}`,
        researchGap: 'Local attractions, convenience factors, area amenities'
      });
    } else if (sessionType === 'restaurant_research') {
      queries.push({
        aspect: 'dining_options',
        searchQuery: `best restaurants ${location} cuisine types fine dining casual local favorites 2024`,
        knownInfo: `Location: ${location}`,
        researchGap: 'Restaurant variety, cuisine options, local recommendations'
      });
    } else if (sessionType === 'travel_research') {
      queries.push({
        aspect: 'travel_logistics',
        searchQuery: `${location} travel guide transportation options how to get there local transit`,
        knownInfo: `Destination: ${location}`,
        researchGap: 'Transportation options, logistics, local transit'
      });
      
      queries.push({
        aspect: 'attractions_activities',
        searchQuery: `${location} top attractions activities things to do must see experiences`,
        knownInfo: `Destination: ${location}`,
        researchGap: 'Tourist attractions, activities, experiences'
      });
    }
    
    return queries;
  }

  generateEntitySpecificQueries(entryAnalysis, entities, sessionType) {
    const queries = [];
    const entityName = entities.personName || entities.organizationName || entryAnalysis.content;
    
    if (sessionType === 'academic_research') {
      queries.push({
        aspect: 'background_expertise',
        searchQuery: `${entityName} background expertise research publications recent work`,
        knownInfo: `Entity: ${entityName}`,
        researchGap: 'Professional background, expertise areas, recent contributions'
      });
      
      queries.push({
        aspect: 'recent_developments',
        searchQuery: `${entityName} recent news updates developments projects 2024`,
        knownInfo: `Entity: ${entityName}`,
        researchGap: 'Recent developments, current projects, latest news'
      });
    }
    
    return queries;
  }

  generateProductSpecificQueries(entryAnalysis, entities, sessionType) {
    const queries = [];
    const product = entities.productName || entities.brand || entryAnalysis.content;
    
    queries.push({
      aspect: 'detailed_specs',
      searchQuery: `${product} detailed specifications technical features performance benchmarks`,
      knownInfo: `Product: ${product}`,
      researchGap: 'Technical specifications, performance data, detailed features'
    });
    
    queries.push({
      aspect: 'user_reviews',
      searchQuery: `${product} user reviews real world experience pros cons reliability`,
      knownInfo: `Product: ${product}`,
      researchGap: 'User experiences, reliability, real-world performance'
    });
    
    queries.push({
      aspect: 'alternatives_comparison',
      searchQuery: `${product} alternatives competitors comparison best options similar products`,
      knownInfo: `Product: ${product}`,
      researchGap: 'Alternative options, competitive comparison, market alternatives'
    });
    
    return queries;
  }

  generateDocumentSpecificQueries(entryAnalysis, entities, sessionType) {
    const queries = [];
    const documentContext = entryAnalysis.contextInsights || entryAnalysis.content.substring(0, 100);
    
    if (sessionType === 'academic_research') {
      queries.push({
        aspect: 'related_research',
        searchQuery: `related research studies ${documentContext} recent findings similar work`,
        knownInfo: `Document content: ${documentContext}`,
        researchGap: 'Related research, recent findings, similar studies'
      });
    }
    
    return queries;
  }

  generateGeneralSpecificQueries(entryAnalysis, entities, sessionType) {
    const queries = [];
    const mainContext = entryAnalysis.contextInsights || entryAnalysis.content.substring(0, 100);
    
    // Extract key terms from context
    const keyTerms = this.extractKeyTermsFromContext(mainContext);
    
    if (keyTerms.length > 0) {
      queries.push({
        aspect: 'detailed_information',
        searchQuery: `${keyTerms.join(' ')} detailed information recent developments comprehensive guide`,
        knownInfo: `Context: ${mainContext}`,
        researchGap: 'Detailed information, recent developments, comprehensive coverage'
      });
    }
    
    return queries;
  }

  extractSpecificEntities(entryAnalysis) {
    const content = entryAnalysis.content.toLowerCase();
    const entities = {};
    
    // Extract hotel brands
    const hotelBrands = ['hilton', 'marriott', 'hyatt', 'sheraton', 'ritz', 'four seasons', 'shangri', 'westin', 'renaissance'];
    for (const brand of hotelBrands) {
      if (content.includes(brand)) {
        entities.hotelBrand = brand.charAt(0).toUpperCase() + brand.slice(1);
        break;
      }
    }
    
    // Extract locations
    const locationMatch = content.match(/\b(toronto|montreal|vancouver|new york|los angeles|chicago|boston|austin|miami|seattle|portland|denver|las vegas|london|paris|tokyo|sydney)\b/i);
    if (locationMatch) {
      entities.location = locationMatch[0];
    }
    
    // Extract brands
    const brands = ['apple', 'samsung', 'google', 'microsoft', 'amazon', 'sony', 'nike'];
    for (const brand of brands) {
      if (content.includes(brand)) {
        entities.brand = brand.charAt(0).toUpperCase() + brand.slice(1);
        break;
      }
    }
    
    // Extract product categories
    const productMatch = content.match(/\b(laptop|phone|headphones|camera|watch|tablet|computer|software|app|hotel|restaurant)\b/i);
    if (productMatch) {
      entities.productCategory = productMatch[0];
    }
    
    return entities;
  }

  extractKeyTermsFromContext(context) {
    // Extract meaningful terms (excluding common words)
    const terms = context.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g) || [];
    const commonWords = ['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'];
    return terms.filter(term => !commonWords.includes(term.toLowerCase())).slice(0, 3);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async performAutomaticResearch(sessionId, clipboardItem) {
    try {
      console.log(`SessionManager: Performing automatic research for item ${clipboardItem.id} in session ${sessionId}`);
      
      // Get the session to understand its context
      const session = await this.getSession(sessionId);
      if (!session) {
        console.log('SessionManager: Session not found, skipping research');
        return;
      }

      // Check if WorkflowEngine is available
      if (!this.workflowEngine) {
        console.log('SessionManager: WorkflowEngine not available, skipping research');
        return;
      }

      // Execute research workflow on the clipboard item
      console.log('SessionManager: Executing research workflow...');
      const researchResult = await this.workflowEngine.executeWorkflow('research', {
        clipboardItem: clipboardItem,
        sessionContext: {
          sessionId: sessionId,
          sessionType: session.session_type,
          sessionLabel: session.session_label
        }
      });

      if (researchResult) {
        console.log('SessionManager: Research completed successfully');
        console.log('SessionManager: Research result keys:', Object.keys(researchResult));
        
        // Update session analysis with research results
        await this.updateSessionWithResearchResults(sessionId, clipboardItem, researchResult);
        
        // Trigger comprehensive session analysis update
        await this.updateComprehensiveSessionAnalysis(sessionId);
        
        // Emit research completed event
        this.emit('session-research-completed', {
          sessionId: sessionId,
          clipboardItemId: clipboardItem.id,
          researchResult: researchResult
        });
      } else {
        console.log('SessionManager: Research returned no results');
      }

    } catch (error) {
      console.error('SessionManager: Automatic research failed:', error);
      
      // Emit research failed event
      this.emit('session-research-failed', {
        sessionId: sessionId,
        clipboardItemId: clipboardItem.id,
        error: error.message
      });
      
      // Don't rethrow the error to prevent it from affecting session creation
    }
  }

  async updateSessionWithResearchResults(sessionId, clipboardItem, researchResult) {
    try {
      console.log(`SessionManager: Updating session ${sessionId} with research results`);
      
      // Get current session data
      const session = await this.getSession(sessionId);
      const sessionItems = await this.getSessionItems(sessionId);
      
      // Parse existing context summary
      let contextSummary = {};
      if (session.context_summary) {
        try {
          contextSummary = JSON.parse(session.context_summary);
        } catch (parseError) {
          console.log('SessionManager: Failed to parse existing context summary, starting fresh');
          contextSummary = {};
        }
      }

      // Parse existing intent analysis
      let intentAnalysis = {};
      if (session.intent_analysis) {
        try {
          intentAnalysis = JSON.parse(session.intent_analysis);
        } catch (parseError) {
          console.log('SessionManager: Failed to parse existing intent analysis, starting fresh');
          intentAnalysis = {};
        }
      }

      // Enhance context summary with research findings
      if (researchResult.research_summary || researchResult.researchSummary) {
        const researchSummary = researchResult.research_summary || researchResult.researchSummary;
        
        if (!contextSummary.researchFindings) {
          contextSummary.researchFindings = [];
        }
        
        // Add new research finding
        contextSummary.researchFindings.push({
          clipboardItemId: clipboardItem.id,
          researchSummary: researchSummary,
          keyFindings: researchResult.key_findings || researchResult.keyFindings || [],
          sources: researchResult.sources || [],
          timestamp: new Date().toISOString(),
          sourceApp: clipboardItem.source_app,
          contentType: 'research_result'
        });

        // Keep only the 5 most recent research findings
        contextSummary.researchFindings = contextSummary.researchFindings.slice(-5);

        // Update the corresponding item in allItems to mark it as researched
        if (contextSummary.allItems) {
          const itemIndex = contextSummary.allItems.findIndex(item => item.clipboardItemId === clipboardItem.id);
          if (itemIndex !== -1) {
            contextSummary.allItems[itemIndex].hasResearch = true;
            contextSummary.allItems[itemIndex].researchType = 'comprehensive';
          }
        }
      }

      // Update session progress and insights
      if (!contextSummary.sessionProgress) {
        contextSummary.sessionProgress = {
          totalItems: sessionItems.length,
          researchedItems: 1,
          nonResearchItems: sessionItems.length - 1,
          lastResearchedAt: new Date().toISOString()
        };
      } else {
        contextSummary.sessionProgress.totalItems = sessionItems.length;
        contextSummary.sessionProgress.researchedItems = (contextSummary.sessionProgress.researchedItems || 0) + 1;
        contextSummary.sessionProgress.nonResearchItems = sessionItems.length - contextSummary.sessionProgress.researchedItems;
        contextSummary.sessionProgress.lastResearchedAt = new Date().toISOString();
      }

      // Generate enhanced session summary that includes both researched and non-researched items
      if (contextSummary.researchFindings && contextSummary.researchFindings.length > 0) {
        const keyTopics = contextSummary.researchFindings
          .flatMap(finding => finding.keyFindings || [])
          .slice(0, 5);
        
        const totalSources = contextSummary.researchFindings
          .reduce((sum, finding) => sum + (finding.sources?.length || 0), 0);

        const researchCount = contextSummary.sessionProgress.researchedItems || 0;
        const nonResearchCount = contextSummary.sessionProgress.nonResearchItems || 0;

        let summaryParts = [`${session.session_type.replace('_', ' ')} session with ${sessionItems.length} items`];
        
        if (researchCount > 0) {
          summaryParts.push(`${researchCount} researched`);
        }
        
        if (nonResearchCount > 0) {
          summaryParts.push(`${nonResearchCount} reference items`);
        }
        
        if (keyTopics.length > 0) {
          summaryParts.push(`covering: ${keyTopics.join(', ')}`);
        }
        
        if (totalSources > 0) {
          summaryParts.push(`${totalSources} sources referenced`);
        }

        contextSummary.sessionSummary = summaryParts.join('. ') + '.';
      }

      // Update intent analysis with research insights
      if (researchResult.suggested_keywords || researchResult.researchQueries) {
        const keywords = researchResult.suggested_keywords || researchResult.researchQueries || [];
        
        if (!intentAnalysis.researchKeywords) {
          intentAnalysis.researchKeywords = [];
        }
        
        // Merge new keywords with existing ones
        intentAnalysis.researchKeywords = [...new Set([...intentAnalysis.researchKeywords, ...keywords])].slice(0, 10);
        
        // Update research progress
        intentAnalysis.researchProgress = {
          totalQueries: keywords.length,
          completedResearch: contextSummary.researchFindings?.length || 0,
          lastUpdated: new Date().toISOString()
        };
      }

      // Save updated session data
      const updateStmt = this.database.db.prepare(`
        UPDATE clipboard_sessions 
        SET context_summary = ?, intent_analysis = ?, last_activity = CURRENT_TIMESTAMP
        WHERE id = ?
      `);
      
      updateStmt.run(
        JSON.stringify(contextSummary),
        JSON.stringify(intentAnalysis),
        sessionId
      );

      console.log('SessionManager: Successfully updated session with research results');
      console.log(`SessionManager: Session now has ${contextSummary.researchFindings?.length || 0} research findings`);

    } catch (error) {
      console.error('SessionManager: Error updating session with research results:', error);
    }
  }

  async getNextSequenceOrder(sessionId) {
    const stmt = this.database.db.prepare(`
      SELECT COALESCE(MAX(sequence_order), 0) + 1 as next_order
      FROM session_members 
      WHERE session_id = ?
    `);
    
    const result = stmt.get(sessionId);
    return result.next_order;
  }

  async updateSessionAnalysis(sessionId) {
    try {
      const sessionItems = await this.getSessionItems(sessionId);
      const session = await this.getSession(sessionId);
      
      if (sessionItems.length < 2) return; // Need at least 2 items for analysis
      
      if (this.aiService && this.aiService.langGraphClient) {
        // Use LangGraph for session analysis
        const analysisResult = await this.aiService.langGraphClient.executeWorkflow('session_analysis', {
          sessionType: session.session_type,
          items: sessionItems.map(item => ({
            content: item.content,
            sourceApp: item.source_app,
            windowTitle: item.window_title,
            timestamp: item.timestamp
          }))
        });
        
        // Update session with analysis
        const updateStmt = this.database.db.prepare(`
          UPDATE clipboard_sessions 
          SET context_summary = ?, intent_analysis = ?
          WHERE id = ?
        `);
        
        updateStmt.run(
          JSON.stringify(analysisResult.contextSummary),
          JSON.stringify(analysisResult.intentAnalysis),
          sessionId
        );
      }
    } catch (error) {
      console.error('SessionManager: Session analysis failed:', error);
    }
  }

  async getSession(sessionId) {
    const stmt = this.database.db.prepare('SELECT * FROM clipboard_sessions WHERE id = ?');
    return stmt.get(sessionId);
  }

  async getSessionItems(sessionId) {
    const stmt = this.database.db.prepare(`
      SELECT c.* FROM clipboard_items c
      JOIN session_members sm ON c.id = sm.clipboard_item_id
      WHERE sm.session_id = ?
      ORDER BY sm.sequence_order ASC
    `);
    
    return stmt.all(sessionId).map(row => ({
      ...row,
      tags: JSON.parse(row.tags || '[]')
    }));
  }

  async getSessionItemCount(sessionId) {
    const stmt = this.database.db.prepare('SELECT COUNT(*) as count FROM session_members WHERE session_id = ?');
    const result = stmt.get(sessionId);
    return result.count;
  }

  async getActiveSessions() {
    // Return ALL sessions (active and expired) for persistent UI display
    const stmt = this.database.db.prepare(`
      SELECT s.*, COUNT(sm.clipboard_item_id) as item_count
      FROM clipboard_sessions s
      LEFT JOIN session_members sm ON s.id = sm.session_id
      GROUP BY s.id
      ORDER BY s.last_activity DESC
    `);
    
    return stmt.all();
  }

  async getSessionsByType(sessionType) {
    const stmt = this.database.db.prepare(`
      SELECT s.*, COUNT(sm.clipboard_item_id) as item_count
      FROM clipboard_sessions s
      LEFT JOIN session_members sm ON s.id = sm.session_id
      WHERE s.session_type = ?
      GROUP BY s.id
      ORDER BY s.last_activity DESC
    `);
    
    return stmt.all(sessionType);
  }

  cleanupExpiredSessions() {
    // Sessions never expire - they remain active indefinitely for persistent UI display
    // This ensures users always see their research sessions in the UI
    console.log('SessionManager: Session expiration disabled - all sessions remain active');
        return;
  }

  async triggerExternalAutomation(session, itemCount) {
    if (!this.externalApiService) {
      return; // External automation not configured
    }

    try {
      // Get session items for automation context
      const sessionItems = await this.getSessionItems(session.id);
      
      const sessionData = {
        sessionId: session.id,
        sessionType: session.session_type,
        sessionLabel: session.session_label,
        itemCount,
        items: sessionItems,
        lastActivity: session.last_activity,
        startTime: session.start_time
      };

      console.log(`SessionManager: Triggering external automation for session ${session.session_label} (${itemCount} items)`);
      
      const result = await this.externalApiService.processSessionUpdate(sessionData);
      
      if (result) {
        console.log(`SessionManager: External automation triggered successfully: ${result.workflowId}`);
        
        // Emit automation event
        this.emit('automation-triggered', {
          sessionId: session.id,
          sessionType: session.session_type,
          workflowId: result.workflowId,
          automationResult: result
        });
      }
      
    } catch (error) {
      console.error('SessionManager: External automation failed:', error);
      
      this.emit('automation-failed', {
        sessionId: session.id,
        sessionType: session.session_type,
        error: error.message
      });
    }
  }

  // External automation management
  enableExternalAutomation(externalApiService) {
    this.externalApiService = externalApiService;
    console.log('SessionManager: External automation enabled');
  }

  disableExternalAutomation() {
    this.externalApiService = null;
    console.log('SessionManager: External automation disabled');
  }

  isExternalAutomationEnabled() {
    return this.externalApiService !== null;
  }

  async clearAllSessions() {
    try {
      console.log('SessionManager: Clearing all sessions...');
      
      // Delete all session members first (due to foreign key constraints)
      const deleteSessionMembersStmt = this.database.db.prepare('DELETE FROM session_members');
      deleteSessionMembersStmt.run();
      
      // Delete all sessions
      const deleteSessionsStmt = this.database.db.prepare('DELETE FROM clipboard_sessions');
      const result = deleteSessionsStmt.run();
      
      // Clear in-memory sessions
      this.activeSessions.clear();
      
      console.log(`SessionManager: Cleared ${result.changes} sessions and all associated data`);
      
      // Emit event to notify UI
      this.emit('all-sessions-cleared');
      
      return { success: true, clearedSessions: result.changes };
    } catch (error) {
      console.error('SessionManager: Error clearing all sessions:', error);
      throw error;
    }
  }

  destroy() {
    if (this.sessionCleanupInterval) {
      clearInterval(this.sessionCleanupInterval);
    }
  }

  async updateComprehensiveSessionAnalysis(sessionId) {
    try {
      console.log(`SessionManager: Running comprehensive session analysis for session ${sessionId}`);
      
      // Get current session and all its items
      const session = await this.getSession(sessionId);
      const sessionItems = await this.getSessionItems(sessionId);
      
      if (sessionItems.length === 0) {
        console.log('SessionManager: No items in session, skipping comprehensive analysis');
        return;
      }

      console.log(`SessionManager: Analyzing ${sessionItems.length} items in session`);

      // Collect all research results from session items
      const sessionItemsWithResearch = [];
      const allResearchFindings = [];
      const allKeywords = [];
      const allSources = [];
      let researchedItemCount = 0;
      let nonResearchedItemCount = 0;
      
      for (const item of sessionItems) {
        let analysisData = null;
        let hasResearch = false;
        
        if (item.analysis_data) {
          try {
            analysisData = JSON.parse(item.analysis_data);
            
            // Extract research results from workflow results
            if (analysisData.workflowResults && analysisData.workflowResults.research) {
              const researchResults = analysisData.workflowResults.research;
              for (const research of researchResults) {
                if (research.researchSummary) {
                  hasResearch = true;
                  allResearchFindings.push({
                    itemId: item.id,
                    summary: research.researchSummary,
                    keyFindings: research.keyFindings || [],
                    sources: research.sources || [],
                    timestamp: research.timestamp,
                    sourceApp: item.source_app,
                    contentType: analysisData.contentType || 'unknown'
                  });
                  
                  // Collect keywords and sources
                  if (research.keyFindings) allKeywords.push(...research.keyFindings);
                  if (research.sources) allSources.push(...research.sources);
                }
              }
            }
          } catch (parseError) {
            console.log(`SessionManager: Error parsing analysis data for item ${item.id}:`, parseError.message);
          }
        }
        
        if (hasResearch) {
          researchedItemCount++;
        } else {
          nonResearchedItemCount++;
        }
        
        sessionItemsWithResearch.push({
          ...item,
          analysisData,
          hasResearch
        });
      }

      console.log(`SessionManager: Found ${allResearchFindings.length} research findings across ${sessionItems.length} items`);
      console.log(`SessionManager: ${researchedItemCount} items with research, ${nonResearchedItemCount} reference items`);

      // Generate comprehensive session analysis using LangGraph if available
      let comprehensiveAnalysis = null;
      if (this.aiService && this.aiService.langGraphClient) {
        console.log('SessionManager: Running comprehensive session workflow analysis...');
        
        try {
          // Include ALL items in the analysis, not just those with research
          const basicKeywords = this.extractBasicKeywords(sessionItems.map(item => `${item.source_app} ${item.window_title}`).join(' '));
          
          comprehensiveAnalysis = await this.aiService.langGraphClient.executeWorkflow('session_management', {
            content: `Comprehensive Session Analysis for ${session.session_type}: ${session.session_label}`,
            context: {
              sourceApp: 'SessionManager',
              windowTitle: `Session Analysis - ${session.session_label}`,
              sessionData: {
                sessionType: session.session_type,
                itemCount: sessionItems.length,
                researchedItems: researchedItemCount,
                nonResearchItems: nonResearchedItemCount,
                researchFindings: allResearchFindings,
                totalSources: allSources.length,
                keyTopics: [...new Set([...allKeywords, ...basicKeywords])].slice(0, 15),
                contentTypes: this.analyzeItemTypes(sessionItems),
                sourceApps: [...new Set(sessionItems.map(item => item.source_app))],
                timespan: this.calculateSessionTimespan(sessionItems)
              }
            },
            existingSession: {
              type: session.session_type,
              label: session.session_label,
              items: sessionItemsWithResearch.map(item => ({
                sourceApp: item.source_app,
                windowTitle: item.window_title,
                hasResearch: item.hasResearch,
                timestamp: item.timestamp,
                contentType: item.analysisData?.contentType || 'unknown'
              }))
            }
          });
          
          console.log('SessionManager: Comprehensive session analysis completed');
        } catch (error) {
          console.error('SessionManager: Comprehensive session analysis failed:', error);
        }
      }

      // Update session with comprehensive analysis
      let contextSummary = {};
      let intentAnalysis = {};
      
      // Parse existing session data
      if (session.context_summary) {
        try {
          contextSummary = JSON.parse(session.context_summary);
        } catch (parseError) {
          contextSummary = {};
        }
      }
      
      if (session.intent_analysis) {
        try {
          intentAnalysis = JSON.parse(session.intent_analysis);
        } catch (parseError) {
          intentAnalysis = {};
        }
      }

      // Update context summary with comprehensive findings (includes all items)
      contextSummary.comprehensiveAnalysis = {
        totalItems: sessionItems.length,
        researchedItems: researchedItemCount,
        nonResearchItems: nonResearchedItemCount,
        researchFindings: allResearchFindings.length,
        totalSources: allSources.length,
        keyTopics: [...new Set([...allKeywords, ...this.extractBasicKeywords(sessionItems.map(item => `${item.source_app} ${item.window_title}`).join(' '))])].slice(0, 15),
        contentTypes: this.analyzeItemTypes(sessionItems),
        sourceApplications: [...new Set(sessionItems.map(item => item.source_app))],
        timespan: this.calculateSessionTimespan(sessionItems),
        lastAnalyzed: new Date().toISOString(),
        sessionProgress: {
          researchCoverage: sessionItems.length > 0 ? Math.round((researchedItemCount / sessionItems.length) * 100) : 0,
          informationDensity: allSources.length > 10 ? 'high' : allSources.length > 5 ? 'medium' : 'low',
          analysisQuality: comprehensiveAnalysis ? 'ai-enhanced' : 'basic'
        }
      };

      // Create consolidated session summary that includes all items
      if (sessionItems.length > 0) {
        const sessionType = session.session_type.replace('_', ' ');
        const contentTypes = this.analyzeItemTypes(sessionItems);
        const sourceApps = [...new Set(sessionItems.map(item => item.source_app))];
        
        let summaryParts = [`${sessionType} session with ${sessionItems.length} items`];
        
        if (researchedItemCount > 0 && nonResearchedItemCount > 0) {
          summaryParts.push(`${researchedItemCount} researched, ${nonResearchedItemCount} reference items`);
        } else if (researchedItemCount > 0) {
          summaryParts.push(`${researchedItemCount} researched items`);
        } else {
          summaryParts.push(`${nonResearchedItemCount} reference items`);
        }
        
        if (contentTypes.length > 0) {
          summaryParts.push(`(${contentTypes.join(', ')})`);
        }
        
        if (allResearchFindings.length > 0) {
          const topKeywords = [...new Set(allKeywords)].slice(0, 5);
          if (topKeywords.length > 0) {
            summaryParts.push(`covering: ${topKeywords.join(', ')}`);
          }
          
          if (allSources.length > 0) {
            summaryParts.push(`${allSources.length} sources referenced`);
          }
        }
        
        contextSummary.sessionSummary = comprehensiveAnalysis?.sessionInsights || 
          summaryParts.join('. ') + '.';
        
        // Add timeline for all items (not just researched ones)
        contextSummary.itemTimeline = sessionItems
          .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
          .slice(0, 8)
          .map(item => ({
            timestamp: item.timestamp,
            sourceApp: item.source_app,
            windowTitle: item.window_title,
            hasResearch: sessionItemsWithResearch.find(sri => sri.id === item.id)?.hasResearch || false
          }));
      }

      // Update intent analysis with comprehensive insights
      if (comprehensiveAnalysis) {
        intentAnalysis.sessionIntent = {
          primaryGoal: comprehensiveAnalysis.intentAnalysis?.primaryIntent || 'research',
          progressStatus: comprehensiveAnalysis.intentAnalysis?.progressStatus || 'in_progress',
          nextActions: comprehensiveAnalysis.nextActions || [],
          confidenceLevel: comprehensiveAnalysis.sessionConfidence || 0.7,
          analysisReasoning: comprehensiveAnalysis.sessionReasoning || 'Comprehensive analysis of session items'
        };
      }

      // Consolidate research insights across all items
      if (allResearchFindings.length > 1) {
        intentAnalysis.crossItemInsights = {
          commonThemes: this.extractCommonThemes(allResearchFindings),
          knowledgeGaps: this.identifyKnowledgeGaps(allResearchFindings, session.session_type),
          recommendedNextSteps: this.generateNextSteps(allResearchFindings, session.session_type),
          researchCoherence: this.assessResearchCoherence(allResearchFindings)
        };
      }

      // Save updated session analysis
      const updateStmt = this.database.db.prepare(`
        UPDATE clipboard_sessions 
        SET context_summary = ?, intent_analysis = ?, last_activity = CURRENT_TIMESTAMP
        WHERE id = ?
      `);
      
      updateStmt.run(
        JSON.stringify(contextSummary),
        JSON.stringify(intentAnalysis),
        sessionId
      );

      console.log('SessionManager: Comprehensive session analysis updated successfully');
      console.log(`SessionManager: Session now has ${allResearchFindings.length} research findings integrated`);

      // Emit comprehensive analysis event
      this.emit('session-analysis-updated', {
        sessionId: sessionId,
        sessionType: session.session_type,
        analysisData: {
          totalResearchFindings: allResearchFindings.length,
          totalSources: allSources.length,
          keyTopics: [...new Set(allKeywords)].slice(0, 5),
          hasComprehensiveAnalysis: !!comprehensiveAnalysis
        }
      });

    } catch (error) {
      console.error('SessionManager: Error in comprehensive session analysis:', error);
    }
  }

  // Helper methods for comprehensive analysis
  extractCommonThemes(researchFindings) {
    const allFindings = researchFindings.flatMap(finding => finding.keyFindings || []);
    const wordCounts = {};
    
    allFindings.forEach(finding => {
      const words = finding.toLowerCase().split(/\s+/);
      words.forEach(word => {
        if (word.length > 3) {
          wordCounts[word] = (wordCounts[word] || 0) + 1;
        }
      });
    });
    
    return Object.entries(wordCounts)
      .filter(([word, count]) => count > 1)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([word]) => word);
  }

  identifyKnowledgeGaps(researchFindings, sessionType) {
    const gaps = [];
    
    // Session-type specific gap analysis
    if (sessionType === 'hotel_research') {
      const hasLocationInfo = researchFindings.some(f => 
        f.keyFindings.some(finding => finding.toLowerCase().includes('location') || finding.toLowerCase().includes('area'))
      );
      const hasPriceInfo = researchFindings.some(f => 
        f.keyFindings.some(finding => finding.toLowerCase().includes('price') || finding.toLowerCase().includes('cost'))
      );
      
      if (!hasLocationInfo) gaps.push('Location and neighborhood information');
      if (!hasPriceInfo) gaps.push('Pricing and value comparison');
    }
    
    return gaps.slice(0, 3);
  }

  generateNextSteps(researchFindings, sessionType) {
    const steps = [];
    
    if (sessionType === 'hotel_research') {
      steps.push('Compare pricing across identified options');
      steps.push('Review customer reviews and ratings');
      if (researchFindings.length > 2) {
        steps.push('Create comparison matrix of key features');
      }
    } else if (sessionType === 'restaurant_research') {
      steps.push('Check availability and make reservations');
      steps.push('Review menu options and dietary accommodations');
    } else {
      steps.push('Gather additional sources for verification');
      steps.push('Organize findings into actionable insights');
    }
    
    return steps.slice(0, 3);
  }

  assessResearchCoherence(researchFindings) {
    // Simple coherence assessment based on keyword overlap
    const allKeywords = researchFindings.flatMap(f => f.keyFindings || []);
    const uniqueKeywords = new Set(allKeywords.map(k => k.toLowerCase()));
    
    const coherenceRatio = uniqueKeywords.size / (allKeywords.length || 1);
    
    if (coherenceRatio > 0.7) return 'low'; // Too many unique keywords, low coherence
    if (coherenceRatio > 0.4) return 'medium';
    return 'high'; // Good keyword overlap, high coherence
  }

  async performSessionResearch(sessionId) {
    try {
      console.log(`SessionManager: Performing comprehensive session research for session ${sessionId}`);
      
      // Get session and all its items
      const session = await this.getSession(sessionId);
      const sessionItems = await this.getSessionItems(sessionId);
      
      if (!session) {
        throw new Error('Session not found');
      }
      
      if (sessionItems.length === 0) {
        throw new Error('Session has no items to research');
      }

      console.log(`SessionManager: Researching session "${session.session_label}" with ${sessionItems.length} items`);

      // Analyze each entry's comprehensive analysis to generate specific research queries
      const entrySpecificResearch = await this.generateEntrySpecificResearchQueries(sessionItems, session.session_type);
      
      console.log(`SessionManager: Generated ${entrySpecificResearch.totalQueries} specific research queries from ${entrySpecificResearch.entries.length} entries`);

      // Check if WorkflowEngine and LangGraph are available
      if (!this.workflowEngine || !this.aiService?.langGraphClient) {
        throw new Error('Research capabilities not available');
      }

      // Execute targeted research for each specific query
      const researchResults = [];
      for (const entry of entrySpecificResearch.entries) {
        if (entry.researchQueries.length > 0) {
          console.log(`SessionManager: Researching entry ${entry.itemId} with ${entry.researchQueries.length} specific queries`);
          
          for (const query of entry.researchQueries) {
            try {
              const researchResult = await this.aiService.langGraphClient.executeWorkflow('research', {
                content: query.searchQuery,
                context: {
                  sourceApp: 'SessionResearcher',
                  windowTitle: `Specific Research: ${query.aspect}`,
                  sessionContext: {
                    sessionId: sessionId,
                    sessionType: session.session_type,
                    entryId: entry.itemId,
                    researchAspect: query.aspect,
                    researchType: 'entry_specific_research'
                  }
                },
                existingAnalysis: {
                  contentType: entry.contentType,
                  tags: entry.tags,
                  contextInsights: entry.contextInsights,
                  knownInformation: query.knownInfo,
                  researchGap: query.researchGap
                }
              });

              if (researchResult) {
                researchResults.push({
                  entryId: entry.itemId,
                  aspect: query.aspect,
                  query: query.searchQuery,
                  result: researchResult,
                  timestamp: new Date().toISOString()
                });
              }
            } catch (error) {
              console.error(`SessionManager: Error researching query "${query.searchQuery}":`, error.message);
            }
          }
        }
      }

      console.log(`SessionManager: Completed ${researchResults.length} specific research queries`);

      // Consolidate and structure all research results
      const consolidatedResults = await this.consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch);

      // Update session with comprehensive research results
      await this.updateSessionWithResearchResults(sessionId, consolidatedResults);

      // Emit session research completed event
      this.emit('session-research-completed', {
        sessionId: sessionId,
        sessionType: session.session_type,
        researchResults: consolidatedResults,
        itemCount: sessionItems.length,
        specificQueries: entrySpecificResearch.totalQueries,
        researchedEntries: entrySpecificResearch.entries.length
      });

      return consolidatedResults;

    } catch (error) {
      console.error('SessionManager: Error performing session research:', error);
      this.emit('session-research-failed', {
        sessionId: sessionId,
        error: error.message
      });
      throw error;
    }
  }

  async generateEntrySpecificResearchQueries(sessionItems, sessionType) {
    const entries = [];
    let totalQueries = 0;

    for (const item of sessionItems) {
      if (!item.analysis_data) {
        console.log(`SessionManager: Skipping item ${item.id} - no comprehensive analysis available`);
        continue;
      }

      try {
        const analysisData = JSON.parse(item.analysis_data);
        const entryAnalysis = {
          itemId: item.id,
          content: item.content,
          contentType: analysisData.contentType || 'unknown',
          tags: analysisData.tags || [],
          contextInsights: analysisData.contextInsights || '',
          visualContext: analysisData.visualContext || null,
          sourceApp: item.source_app,
          windowTitle: item.window_title
        };

        // Generate specific research queries based on content type and context
        const researchQueries = this.generateSpecificResearchQueries(entryAnalysis, sessionType);
        
        if (researchQueries.length > 0) {
          entries.push({
            ...entryAnalysis,
            researchQueries: researchQueries
          });
          totalQueries += researchQueries.length;
          console.log(`SessionManager: Generated ${researchQueries.length} queries for ${entryAnalysis.contentType} entry`);
        }

      } catch (parseError) {
        console.log(`SessionManager: Error parsing analysis data for item ${item.id}:`, parseError.message);
      }
    }

    return {
      entries: entries,
      totalQueries: totalQueries,
      sessionType: sessionType
    };
  }

  generateSpecificResearchQueries(entryAnalysis, sessionType) {
    const queries = [];
    const content = entryAnalysis.content.toLowerCase();
    const tags = entryAnalysis.tags;
    const contextInsights = entryAnalysis.contextInsights || '';
    
    // Extract specific entities from the content
    const entities = this.extractSpecificEntities(entryAnalysis);
    
    switch (entryAnalysis.contentType) {
      case 'url':
        queries.push(...this.generateURLSpecificQueries(entryAnalysis, entities, sessionType));
        break;
        
      case 'location':
      case 'address':
        queries.push(...this.generateLocationSpecificQueries(entryAnalysis, entities, sessionType));
        break;
        
      case 'person':
      case 'organization':
        queries.push(...this.generateEntitySpecificQueries(entryAnalysis, entities, sessionType));
        break;
        
      case 'product':
        queries.push(...this.generateProductSpecificQueries(entryAnalysis, entities, sessionType));
        break;
        
      case 'document':
      case 'data':
        queries.push(...this.generateDocumentSpecificQueries(entryAnalysis, entities, sessionType));
        break;
        
      default:
        queries.push(...this.generateGeneralSpecificQueries(entryAnalysis, entities, sessionType));
    }

    return queries.slice(0, 3); // Limit to 3 most important queries per entry
  }

  generateURLSpecificQueries(entryAnalysis, entities, sessionType) {
    const queries = [];
    const url = entryAnalysis.content;
    
    // Extract domain and infer content type
    const domain = url.match(/https?:\/\/(?:www\.)?([^\/]+)/)?.[1] || '';
    
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand) {
        queries.push({
          aspect: 'pricing_comparison',
          searchQuery: `${entities.hotelBrand} hotel ${entities.location || ''} pricing rates booking deals current offers`,
          knownInfo: `Hotel brand: ${entities.hotelBrand}`,
          researchGap: 'Current pricing, availability, special offers, booking comparison'
        });
        
        queries.push({
          aspect: 'amenities_details',
          searchQuery: `${entities.hotelBrand} ${entities.location || ''} amenities facilities services features guest reviews`,
          knownInfo: `Hotel: ${entities.hotelBrand}`,
          researchGap: 'Detailed amenities, guest experiences, facility quality'
        });
        
        if (entities.location) {
          queries.push({
            aspect: 'location_benefits',
            searchQuery: `${entities.hotelBrand} ${entities.location} location advantages nearby attractions transportation access`,
            knownInfo: `Hotel ${entities.hotelBrand} in ${entities.location}`,
            researchGap: 'Location advantages, nearby attractions, transportation options'
          });
        }
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName) {
        queries.push({
          aspect: 'menu_pricing',
          searchQuery: `${entities.restaurantName} ${entities.location || ''} menu prices current offerings specialties`,
          knownInfo: `Restaurant: ${entities.restaurantName}`,
          researchGap: 'Current menu, pricing, signature dishes, seasonal offerings'
        });
        
        queries.push({
          aspect: 'dining_experience',
          searchQuery: `${entities.restaurantName} ${entities.location || ''} reviews dining experience service quality atmosphere`,
          knownInfo: `Restaurant: ${entities.restaurantName}`,
          researchGap: 'Dining experience, service quality, atmosphere, customer reviews'
        });
      }
    } else if (sessionType === 'product_research') {
      if (entities.productName || entities.brand) {
        const product = entities.productName || entities.brand;
        queries.push({
          aspect: 'specifications_comparison',
          searchQuery: `${product} specifications features comparison alternatives competitors 2024`,
          knownInfo: `Product: ${product}`,
          researchGap: 'Detailed specifications, feature comparison, competitive analysis'
        });
        
        queries.push({
          aspect: 'pricing_availability',
          searchQuery: `${product} current price best deals where to buy availability stock`,
          knownInfo: `Product: ${product}`,
          researchGap: 'Current pricing, best deals, purchasing options, availability'
        });
      }
    }
    
    return queries;
  }

  generateLocationSpecificQueries(entryAnalysis, entities, sessionType) {
    const queries = [];
    const location = entities.location || entryAnalysis.content;
    
    if (sessionType === 'hotel_research') {
      queries.push({
        aspect: 'area_hotels',
        searchQuery: `best hotels ${location} luxury boutique budget options 2024 recommendations`,
        knownInfo: `Location: ${location}`,
        researchGap: 'Hotel options in the area, categories, recommendations'
      });
      
      queries.push({
        aspect: 'location_advantages',
        searchQuery: `${location} attractions nearby amenities transportation shopping dining convenience`,
        knownInfo: `Area: ${location}`,
        researchGap: 'Local attractions, convenience factors, area amenities'
      });
    } else if (sessionType === 'restaurant_research') {
      queries.push({
        aspect: 'dining_options',
        searchQuery: `best restaurants ${location} cuisine types fine dining casual local favorites 2024`,
        knownInfo: `Location: ${location}`,
        researchGap: 'Restaurant variety, cuisine options, local recommendations'
      });
    } else if (sessionType === 'travel_research') {
      queries.push({
        aspect: 'travel_logistics',
        searchQuery: `${location} travel guide transportation options how to get there local transit`,
        knownInfo: `Destination: ${location}`,
        researchGap: 'Transportation options, logistics, local transit'
      });
      
      queries.push({
        aspect: 'attractions_activities',
        searchQuery: `${location} top attractions activities things to do must see experiences`,
        knownInfo: `Destination: ${location}`,
        researchGap: 'Tourist attractions, activities, experiences'
      });
    }
    
    return queries;
  }

  generateEntitySpecificQueries(entryAnalysis, entities, sessionType) {
    const queries = [];
    const entityName = entities.personName || entities.organizationName || entryAnalysis.content;
    
    if (sessionType === 'academic_research') {
      queries.push({
        aspect: 'background_expertise',
        searchQuery: `${entityName} background expertise research publications recent work`,
        knownInfo: `Entity: ${entityName}`,
        researchGap: 'Professional background, expertise areas, recent contributions'
      });
      
      queries.push({
        aspect: 'recent_developments',
        searchQuery: `${entityName} recent news updates developments projects 2024`,
        knownInfo: `Entity: ${entityName}`,
        researchGap: 'Recent developments, current projects, latest news'
      });
    }
    
    return queries;
  }

  generateProductSpecificQueries(entryAnalysis, entities, sessionType) {
    const queries = [];
    const product = entities.productName || entities.brand || entryAnalysis.content;
    
    queries.push({
      aspect: 'detailed_specs',
      searchQuery: `${product} detailed specifications technical features performance benchmarks`,
      knownInfo: `Product: ${product}`,
      researchGap: 'Technical specifications, performance data, detailed features'
    });
    
    queries.push({
      aspect: 'user_reviews',
      searchQuery: `${product} user reviews real world experience pros cons reliability`,
      knownInfo: `Product: ${product}`,
      researchGap: 'User experiences, reliability, real-world performance'
    });
    
    queries.push({
      aspect: 'alternatives_comparison',
      searchQuery: `${product} alternatives competitors comparison best options similar products`,
      knownInfo: `Product: ${product}`,
      researchGap: 'Alternative options, competitive comparison, market alternatives'
    });
    
    return queries;
  }

  generateDocumentSpecificQueries(entryAnalysis, entities, sessionType) {
    const queries = [];
    const documentContext = entryAnalysis.contextInsights || entryAnalysis.content.substring(0, 100);
    
    if (sessionType === 'academic_research') {
      queries.push({
        aspect: 'related_research',
        searchQuery: `related research studies ${documentContext} recent findings similar work`,
        knownInfo: `Document content: ${documentContext}`,
        researchGap: 'Related research, recent findings, similar studies'
      });
    }
    
    return queries;
  }

  generateGeneralSpecificQueries(entryAnalysis, entities, sessionType) {
    const queries = [];
    const mainContext = entryAnalysis.contextInsights || entryAnalysis.content.substring(0, 100);
    
    // Extract key terms from context
    const keyTerms = this.extractKeyTermsFromContext(mainContext);
    
    if (keyTerms.length > 0) {
      queries.push({
        aspect: 'detailed_information',
        searchQuery: `${keyTerms.join(' ')} detailed information recent developments comprehensive guide`,
        knownInfo: `Context: ${mainContext}`,
        researchGap: 'Detailed information, recent developments, comprehensive coverage'
      });
    }
    
    return queries;
  }

  extractSpecificEntities(entryAnalysis) {
    const content = entryAnalysis.content.toLowerCase();
    const entities = {};
    
    // Extract hotel brands
    const hotelBrands = ['hilton', 'marriott', 'hyatt', 'sheraton', 'ritz', 'four seasons', 'shangri', 'westin', 'renaissance'];
    for (const brand of hotelBrands) {
      if (content.includes(brand)) {
        entities.hotelBrand = brand.charAt(0).toUpperCase() + brand.slice(1);
        break;
      }
    }
    
    // Extract locations
    const locationMatch = content.match(/\b(toronto|montreal|vancouver|new york|los angeles|chicago|boston|austin|miami|seattle|portland|denver|las vegas|london|paris|tokyo|sydney)\b/i);
    if (locationMatch) {
      entities.location = locationMatch[0];
    }
    
    // Extract brands
    const brands = ['apple', 'samsung', 'google', 'microsoft', 'amazon', 'sony', 'nike'];
    for (const brand of brands) {
      if (content.includes(brand)) {
        entities.brand = brand.charAt(0).toUpperCase() + brand.slice(1);
        break;
      }
    }
    
    // Extract product categories
    const productMatch = content.match(/\b(laptop|phone|headphones|camera|watch|tablet|computer|software|app|hotel|restaurant)\b/i);
    if (productMatch) {
      entities.productCategory = productMatch[0];
    }
    
    return entities;
  }

  extractKeyTermsFromContext(context) {
    // Extract meaningful terms (excluding common words)
    const terms = context.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g) || [];
    const commonWords = ['the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'];
    return terms.filter(term => !commonWords.includes(term.toLowerCase())).slice(0, 3);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
    } else {
      summary += 'Essential information gathered for informed comparison.';
    }
    
    return summary;
  }

  determineActualResearchIntent(researchContent, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    // Determine intent based on content and aspects
    if (researched.length > 1) {
      if (sessionType === 'hotel_research') {
        return `Compare ${researched.slice(0, 2).join(' and ')} for best accommodation`;
      } else if (sessionType === 'restaurant_research') {
        return `Evaluate ${researched.slice(0, 2).join(' and ')} dining options`;
      } else if (sessionType === 'product_research') {
        return `Compare ${researched.slice(0, 2).join(' vs ')} features and pricing`;
      } else if (sessionType === 'travel_research') {
        return `Plan comprehensive trip covering ${researched.slice(0, 2).join(' and ')}`;
      }
    } else {
      const subject = researched[0];
      if (aspects.includes('pricing_comparison')) {
        return `Find best pricing and deals for ${subject}`;
      } else if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
        return `Evaluate features and amenities of ${subject}`;
      } else if (aspects.includes('location_benefits')) {
        return `Assess location advantages of ${subject}`;
      } else if (aspects.includes('user_reviews')) {
        return `Analyze user experiences with ${subject}`;
      } else {
        return `Research and analyze ${subject}`;
      }
    }
    
    return `${sessionType.replace('_', ' ')} research`;
  }

  extractContentBasedGoals(researchContent, sessionType) {
    const goals = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      goals.push(`Compare options between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      goals.push('Find competitive pricing and best value');
    }
    
    if (aspects.includes('amenities_details') || aspects.includes('specifications_comparison')) {
      goals.push('Evaluate features against requirements');
    }
    
    if (aspects.includes('location_benefits')) {
      goals.push('Assess location advantages and accessibility');
    }
    
    if (aspects.includes('user_reviews')) {
      goals.push('Understand real user experiences');
    }
    
    if (sessionType === 'hotel_research') {
      goals.push('Select optimal accommodation option');
    } else if (sessionType === 'restaurant_research') {
      goals.push('Choose best dining experience');
    } else if (sessionType === 'product_research') {
      goals.push('Make informed purchase decision');
    }
    
    return goals.slice(0, 5);
  }

  generateContentBasedNextSteps(researchContent, sessionType) {
    const steps = [];
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length > 1) {
      steps.push(`Finalize selection between ${researched.slice(0, 2).join(' and ')}`);
    }
    
    if (aspects.includes('pricing_comparison')) {
      steps.push('Compare final pricing and book best deal');
    }
    
    if (sessionType === 'hotel_research') {
      steps.push('Check availability and make reservation');
    } else if (sessionType === 'restaurant_research') {
      steps.push('Make dining reservations');
    } else if (sessionType === 'product_research') {
      steps.push('Proceed with purchase from preferred vendor');
    } else if (sessionType === 'travel_research') {
      steps.push('Finalize travel arrangements and bookings');
    }
    
    return steps.slice(0, 4);
  }

  async consolidateEntrySpecificResearch(sessionId, researchResults, entrySpecificResearch) {
    console.log('SessionManager: Consolidating entry-specific research results into structured format');
    
    // Group results by entry and aspect
    const resultsByEntry = {};
    const allSources = [];
    const allKeyFindings = [];
    const allSearchQueries = [];
    
    for (const result of researchResults) {
      if (!resultsByEntry[result.entryId]) {
        resultsByEntry[result.entryId] = {
          entryId: result.entryId,
          aspects: {},
          totalSources: 0,
          researchCount: 0
        };
      }
      
      const entryResult = resultsByEntry[result.entryId];
      entryResult.aspects[result.aspect] = {
        query: result.query,
        result: result.result,
        timestamp: result.timestamp
      };
      entryResult.researchCount++;
      
      // Collect all findings and sources
      if (result.result.sources) {
        allSources.push(...result.result.sources);
        entryResult.totalSources += result.result.sources.length;
      }
      
      if (result.result.keyFindings || result.result.key_findings) {
        const findings = result.result.keyFindings || result.result.key_findings;
        allKeyFindings.push(...findings);
      }
      
      allSearchQueries.push(result.query);
    }
    
    // Extract actual research content from queries and results
    const researchContent = this.extractActualResearchContent(entrySpecificResearch.entries, resultsByEntry, entrySpecificResearch.sessionType);
    
    // Generate session-level insights from specific research
    const sessionType = entrySpecificResearch.sessionType;
    const totalEntries = entrySpecificResearch.entries.length;
    const researchedEntries = Object.keys(resultsByEntry).length;
    
    // Create comprehensive summary focusing on actual research content
    const comprehensiveSummary = this.generateContentFocusedSummary(
      researchContent, 
      resultsByEntry, 
      allSources.length,
      sessionType
    );
    
    // Extract key findings organized by research aspect
    const organizedFindings = this.organizeKeyFindingsByAspect(resultsByEntry);
    
    // Determine primary research intent from actual content
    const primaryIntent = this.determineActualResearchIntent(researchContent, sessionType);
    
    const structuredResults = {
      sessionId: sessionId,
      researchType: 'entry_specific_research',
      researchObjective: researchContent.researchObjective,
      timestamp: new Date().toISOString(),
      
      // Intent analysis based on actual research content
      intentAnalysis: {
        primaryIntent: primaryIntent,
        researchGoals: this.extractContentBasedGoals(researchContent, sessionType),
        completionStatus: researchedEntries >= totalEntries ? 'comprehensive' : 'partial',
        nextSteps: this.generateContentBasedNextSteps(researchContent, sessionType),
        confidenceLevel: Math.min(0.9, 0.6 + (researchedEntries / totalEntries) * 0.3)
      },
      
      // Key findings organized by research aspect
      keyFindings: organizedFindings.slice(0, 10),
      
      // Comprehensive summary
      comprehensiveSummary: comprehensiveSummary,
      
      // Research data
      researchData: {
        researchSummary: comprehensiveSummary,
        sources: [...new Set(allSources.map(s => JSON.stringify(s)))].map(s => JSON.parse(s)), // Deduplicate sources
        totalSources: allSources.length,
        uniqueSources: [...new Set(allSources.map(s => s.url || s.source || s.title))].length,
        confidence: Math.min(0.95, 0.7 + (allSources.length / (entrySpecificResearch.totalQueries * 2))),
        searchQueries: [...new Set(allSearchQueries)],
        researchCategories: ['entry-specific', 'targeted', 'comprehensive']
      },
      
      // Session insights with actual research content
      sessionInsights: {
        entryAnalysis: `Researched ${researchContent.entitiesResearched.join(', ')}`,
        researchCoverage: `${researchContent.aspectsCovered.join(', ')} analysis`,
        aspectsCovered: this.getResearchAspectsSummary(resultsByEntry),
        informationDepth: allSources.length > 15 ? 'comprehensive' : allSources.length > 8 ? 'substantial' : 'moderate',
        thematicCoherence: 'high', // Entry-specific research has high thematic coherence by design
        researchQuality: allSources.length > 0 ? 'verified' : 'preliminary'
      },
      
      // Entry-specific research details
      entrySpecificData: {
        entriesResearched: researchedEntries,
        totalEntries: totalEntries,
        resultsByEntry: resultsByEntry,
        coveragePercentage: Math.round((researchedEntries / totalEntries) * 100),
        researchContent: researchContent
      }
    };
    
    console.log('SessionManager: Structured specific research results:', {
      entriesResearched: researchedEntries,
      researchObjective: researchContent.researchObjective,
      entitiesResearched: researchContent.entitiesResearched,
      primaryIntent: structuredResults.intentAnalysis.primaryIntent
    });
    
    return structuredResults;
  }

  extractActualResearchContent(entries, resultsByEntry, sessionType) {
    const entities = {
      hotels: new Set(),
      locations: new Set(),
      brands: new Set(),
      products: new Set(),
      restaurants: new Set(),
      people: new Set(),
      organizations: new Set()
    };
    
    const aspectsCovered = new Set();
    const researched = [];
    
    // Extract entities from each entry that was researched
    for (const entry of entries) {
      if (resultsByEntry[entry.itemId]) {
        // Extract entities from the entry content and context
        const entryEntities = this.extractSpecificEntities(entry);
        
        // Add to entities collections
        if (entryEntities.hotelBrand) entities.hotels.add(entryEntities.hotelBrand);
        if (entryEntities.location) entities.locations.add(entryEntities.location);
        if (entryEntities.brand) entities.brands.add(entryEntities.brand);
        
        // Extract from research aspects
        Object.keys(resultsByEntry[entry.itemId].aspects).forEach(aspect => {
          aspectsCovered.add(aspect);
        });
        
        // Determine what was researched for this entry
        const entryResearch = this.determineEntryResearchSubject(entry, entryEntities, sessionType);
        if (entryResearch) {
          researched.push(entryResearch);
        }
      }
    }
    
    // Generate research objective based on actual content
    const researchObjective = this.generateContentBasedObjective(entities, researched, sessionType);
    
    return {
      entities: entities,
      entitiesResearched: researched,
      aspectsCovered: Array.from(aspectsCovered),
      researchObjective: researchObjective,
      sessionType: sessionType
    };
  }

  determineEntryResearchSubject(entry, entities, sessionType) {
    if (sessionType === 'hotel_research') {
      if (entities.hotelBrand && entities.location) {
        return `${entities.hotelBrand} in ${entities.location}`;
      } else if (entities.hotelBrand) {
        return `${entities.hotelBrand} hotels`;
      } else if (entities.location) {
        return `hotels in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('hotel')) {
        return 'hotel options';
      }
    } else if (sessionType === 'restaurant_research') {
      if (entities.restaurantName && entities.location) {
        return `${entities.restaurantName} in ${entities.location}`;
      } else if (entities.location) {
        return `restaurants in ${entities.location}`;
      } else if (entry.content.toLowerCase().includes('restaurant')) {
        return 'restaurant options';
      }
    } else if (sessionType === 'product_research') {
      if (entities.brand && entities.productCategory) {
        return `${entities.brand} ${entities.productCategory}`;
      } else if (entities.brand) {
        return `${entities.brand} products`;
      } else if (entities.productCategory) {
        return `${entities.productCategory} options`;
      }
    } else if (sessionType === 'travel_research') {
      if (entities.location) {
        return `travel to ${entities.location}`;
      }
    }
    
    // Fallback: extract meaningful terms from content
    const meaningfulTerms = entry.content.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,1}\b/g)?.slice(0, 2);
    if (meaningfulTerms && meaningfulTerms.length > 0) {
      return meaningfulTerms.join(' ');
    }
    
    return null;
  }

  generateContentBasedObjective(entities, researched, sessionType) {
    if (researched.length === 0) {
      return `${sessionType.replace('_', ' ')} analysis`;
    }
    
    const uniqueResearched = [...new Set(researched)];
    
    if (sessionType === 'hotel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} research and analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} comparison`;
      }
    } else if (sessionType === 'restaurant_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} dining research`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} restaurant comparison`;
      }
    } else if (sessionType === 'product_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} product analysis`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' vs ')} comparison`;
      }
    } else if (sessionType === 'travel_research') {
      if (uniqueResearched.length === 1) {
        return `${uniqueResearched[0]} planning`;
      } else {
        return `${uniqueResearched.slice(0, 2).join(' and ')} travel planning`;
      }
    }
    
    // Fallback
    if (uniqueResearched.length === 1) {
      return `${uniqueResearched[0]} research`;
    } else {
      return `${uniqueResearched.slice(0, 3).join(', ')} analysis`;
    }
  }

  generateContentFocusedSummary(researchContent, resultsByEntry, totalSources, sessionType) {
    const researched = researchContent.entitiesResearched;
    const aspects = researchContent.aspectsCovered;
    
    if (researched.length === 0) {
      return `Completed ${sessionType.replace('_', ' ')} analysis with ${totalSources} sources providing comprehensive coverage.`;
    }
    
    let summary = '';
    
    // Start with what was actually researched
    if (researched.length === 1) {
      summary = `Comprehensive research on ${researched[0]}. `;
    } else if (researched.length === 2) {
      summary = `Detailed analysis comparing ${researched[0]} and ${researched[1]}. `;
    } else {
      summary = `Multi-option research covering ${researched.slice(0, 2).join(', ')} and ${researched.length - 2} other options. `;
    }
    
    // Add aspect-specific insights
    const aspectDescriptions = {
      'pricing_comparison': 'pricing and booking options',
      'amenities_details': 'facilities and amenities',
      'location_benefits': 'location advantages',
      'menu_pricing': 'menu options and pricing',
      'dining_experience': 'dining experience quality',
      'specifications_comparison': 'technical specifications',
      'user_reviews': 'user experiences and reviews',
      'alternatives_comparison': 'alternative options',
      'travel_logistics': 'travel logistics',
      'attractions_activities': 'attractions and activities'
    };
    
    const relevantAspects = aspects.map(aspect => aspectDescriptions[aspect]).filter(Boolean);
    if (relevantAspects.length > 0) {
      summary += `Analysis focused on ${relevantAspects.slice(0, 3).join(', ')}. `;
    }
    
    // Add source information
    if (totalSources > 0) {
      summary += `Research validated through ${totalSources} reliable sources providing detailed insights. `;
    }
    
    // Add quality assessment based on content
    const averageSourcesPerEntry = totalSources / researched.length;
    if (averageSourcesPerEntry >= 3) {
      summary += 'Comprehensive coverage achieved with in-depth analysis of each option.';
    } else if (averageSourcesPerEntry >= 2) {
      summary += 'Substantial research providing solid foundation for decision-making.';
   